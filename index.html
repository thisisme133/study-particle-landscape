<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Three.js Point Cloud Viewer - Heightmaps, Google 3D Tiles & PLY</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0e0f13; color: #e6e6e6; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #overlayInfo {
      position: fixed;
      bottom: 12px;
      left: 12px;
      font-size: 12px;
      color: #b0b5bd;
      background: rgba(20, 22, 28, 0.75);
      padding: 6px 10px;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      z-index: 10;
    }
    #overlayInfo a {
      color: #9bd;
    }
    canvas.drop-target {
      display: block;
      width: 100vw;
      height: 100vh;
      outline: 1px solid transparent;
      transition: outline-color 0.2s ease;
    }
    canvas.drop-target.drag-over {
      outline: 2px dashed rgba(155, 187, 221, 0.85);
    }
    a, a:visited { color: #9bd; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div id="overlayInfo">Drag a heightmap, PLY or LAZ file onto the canvas. Free terrain generation via Open-Elevation API. Project by <a href="https://x.com/taylor_sntx" target="_blank" rel="noopener">Taylor</a></div>
  <input id="heightmapFile" type="file" accept="image/png,image/jpeg,image/webp" style="display:none;">

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/",
        "tweakpane": "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.js",
        "@loaders.gl/core": "https://cdn.jsdelivr.net/npm/@loaders.gl/core@4.3.4/dist/index.js",
        "@loaders.gl/las": "https://cdn.jsdelivr.net/npm/@loaders.gl/las@4.3.4/dist/index.js",
        "@loaders.gl/schema": "https://cdn.jsdelivr.net/npm/@loaders.gl/schema@4.3.4/dist/index.js",
        "@loaders.gl/loader-utils": "https://cdn.jsdelivr.net/npm/@loaders.gl/loader-utils@4.3.4/dist/index.js",
        "@loaders.gl/worker-utils": "https://cdn.jsdelivr.net/npm/@loaders.gl/worker-utils@4.3.4/dist/index.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { Pane } from 'tweakpane';
    import { load } from '@loaders.gl/core';
    import { LASLoader } from '@loaders.gl/las';

    const DEFAULT_HEIGHTMAP_URL = 'assets/heightmap_512x512.png';
    // Track mouse for hover effects
    window.__mouseNdc = new THREE.Vector2(-2, -2);
    window.addEventListener('mousemove', (e) => {
      window.__mouseNdc.x = (e.clientX / window.innerWidth) * 2 - 1;
      window.__mouseNdc.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0f13);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 18);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    renderer.domElement.classList.add('drop-target');

    const clock = new THREE.Clock();
    const initialCamPos = new THREE.Vector3().copy(camera.position);
    const initialCamQuat = new THREE.Quaternion().copy(camera.quaternion);
    let defaultCamPos;
    let defaultCamQuat;
    

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // Ground grid for scale reference
    const grid = new THREE.GridHelper(200, 200, 0x33353a, 0x1e2026);
    grid.material.opacity = 0.35;
    grid.material.transparent = true;
    grid.material.depthWrite = false;
    grid.material.depthTest = false;
    grid.visible = false;
    scene.add(grid);

    // Plane setup
    const initialSize = 12; // default tile size
    let segments = 256; // will be controlled by UI (subdivisions)

    let plane = null; // unused after tiling in pointcloud mode
    const pointMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uMap: { value: null },
        uScale: { value: 2.8 },
        uBias: { value: -2.8 * 0.5 },
        uColor: { value: new THREE.Color(0x8a8f9a) },
        uPointSize: { value: 2.0 },
        uTime: { value: 0.0 },
        uJitter: { value: 0.02 },
        uMaskCenter: { value: new THREE.Vector2(0.0, 0.0) },
        uMaskRadius: { value: 4.0 },
        uMaskFeather: { value: 0.6 },
        uHoverCenter: { value: new THREE.Vector2(9999.0, 9999.0) },
        uHoverRadius: { value: 1.6 },
        uHoverStrength: { value: 0.8 },
        uHoverSnap: { value: 2.0 },
        uHoverColor: { value: new THREE.Color(0xffcc55) },
        uHoverEnabled: { value: 1.0 },
        // Airplane hover highlight
        uAirplanePos: { value: new THREE.Vector3(9999, 9999, 9999) },
        uAirplaneHoverEnabled: { value: 0.0 },
        uAirplaneHoverRadius: { value: 2.0 },
        uAirplaneColorFar: { value: new THREE.Color(0x00ffaa) },  // cyan-green when high/safe
        uAirplaneColorClose: { value: new THREE.Color(0xff0000) }, // pure red when low/danger
        // Fog uniforms expected by renderer when material.fog === true
        fogColor: { value: new THREE.Color(0x0e0f13) },
        fogNear: { value: 1 },
        fogFar: { value: 1000 },
        fogDensity: { value: 0.00025 }
      },
      transparent: true,
      depthWrite: true,
      blending: THREE.NormalBlending,
      fog: false,
      vertexShader: `
        #include <uv_pars_vertex>
        varying float vMaskAlpha;
        varying float vHoverMix;
        varying float vAirplaneMix;
        varying float vAirplaneProximity;
        #include <fog_pars_vertex>
        uniform sampler2D uMap;
        uniform float uScale;
        uniform float uBias;
        uniform float uPointSize;
        uniform float uTime;
        uniform float uJitter;
        uniform vec2 uMaskCenter;
        uniform float uMaskRadius;
        uniform float uMaskFeather;
        uniform vec2 uHoverCenter;
        uniform float uHoverRadius;
        uniform float uHoverStrength;
        uniform float uHoverSnap;
        uniform float uHoverEnabled;
        uniform vec3 uAirplanePos;
        uniform float uAirplaneHoverEnabled;
        uniform float uAirplaneHoverRadius;
        // hash-based 2D noise -> scalar in [-1,1]
        float hash(vec2 p){
          return -1.0 + 2.0 * fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }
        void main() {
          #include <uv_vertex>
          vec3 p = position;
          float h = 0.0;
          #ifdef USE_UV
          vec3 c = texture2D(uMap, vUv).rgb;
          h = (c.r + c.g + c.b) / 3.0;
          #endif
          // apply small XY jitter in object space based on vUv
          if (uJitter > 0.0) {
            float jx = hash(vUv + 0.123) * uJitter;
            float jz = hash(vUv + 4.567) * uJitter;
            p.x += jx;
            p.z += jz;
          }
          // base height
          float baseY = h * uScale + uBias;
          p.y = baseY;
          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = max(1.0, uPointSize * (300.0 / max(1.0, -mvPosition.z)));
          vec4 worldPos = modelMatrix * vec4(p, 1.0);
          float d = length(worldPos.xz - uMaskCenter);
          float edge0 = uMaskRadius;
          float edge1 = uMaskRadius + max(0.0001, uMaskFeather);
          vMaskAlpha = 1.0 - smoothstep(edge0, edge1, d);
          // mouse hover influence factor 0..1 with soft falloff
          float hd = length(worldPos.xz - uHoverCenter);
          float hEdge = uHoverRadius;
          vHoverMix = uHoverEnabled * (1.0 - smoothstep(hEdge, hEdge + 0.5, hd));
          // airplane hover - distance in XZ plane from airplane
          float airDist = length(worldPos.xz - uAirplanePos.xz);
          float airEdge = uAirplaneHoverRadius;
          vAirplaneMix = uAirplaneHoverEnabled * (1.0 - smoothstep(airEdge, airEdge + 0.8, airDist));
          // proximity factor: how close is the particle to airplane vertically (0=far, 1=close)
          // Use signed distance - particles ABOVE airplane are far (green), BELOW or at same level are close (red)
          float vertDist = uAirplanePos.y - worldPos.y; // positive when airplane is above particle
          vAirplaneProximity = 1.0 - clamp(vertDist / 0.6, 0.0, 1.0); // 0=airplane high above, 1=at or below particle
          #include <fog_vertex>
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform vec3 uHoverColor;
        uniform vec3 uAirplaneColorFar;
        uniform vec3 uAirplaneColorClose;
        varying float vMaskAlpha;
        varying float vHoverMix;
        varying float vAirplaneMix;
        varying float vAirplaneProximity;
        #include <fog_pars_fragment>
        void main() {
          vec2 pc = gl_PointCoord - 0.5;
          float r = length(pc);
          float disc = 1.0 - smoothstep(0.5, 0.55, r);
          float alpha = disc * vMaskAlpha;
          if (alpha <= 0.001) discard;
          // Start with base color
          vec3 col = uColor;
          // Apply mouse hover color
          col = mix(col, uHoverColor, vHoverMix);
          // Apply airplane hover - blend between far (orange) and close (red) based on proximity
          vec3 airplaneColor = mix(uAirplaneColorFar, uAirplaneColorClose, vAirplaneProximity);
          col = mix(col, airplaneColor, vAirplaneMix);
          gl_FragColor = vec4(col, alpha);
          #include <fog_fragment>
        }
      `
    });
    // Enable UV chunks in shader includes
    pointMaterial.defines = pointMaterial.defines || {};
    pointMaterial.defines.USE_UV = '';
    

    // (Trail system removed)

    // ========== AIRPLANE ==========
    let airplane = null;
    let airplaneGroup = null;
    const airplaneState = {
      enabled: false,
      x: 0,          // current X position (world space offset from center)
      targetX: 0,    // target X position
      y: 0,          // current Y offset (altitude adjustment)
      targetY: 0,    // target Y offset
      tilt: 0,       // current tilt (roll) angle
      pitch: 0,      // current pitch angle
      speed: 3,      // horizontal movement speed
      vertSpeed: 2,  // vertical movement speed
      maxOffset: 5.5,  // max left/right offset
      altitudeRange: 1.5, // max up/down range
      smoothing: 8,  // lerp smoothing factor
      height: -2.5,  // height offset from camera
      size: 0.4,     // scale of the airplane
      distance: 3.5, // distance ahead of camera
      // Collision state
      isColliding: false,
      collisionShake: 0,
      collisionThreshold: -0.1, // negative = only trigger when actually below terrain
    };
    
    // Store airplane materials for color change on collision
    let airplaneMaterials = [];
    const keysPressed = { left: false, right: false, up: false, down: false };

    function createAirplane() {
      // Create a retro wireframe arrow pointing forward
      const group = new THREE.Group();
      
      // Arrow outline - wireframe style like retro arcade radar
      // Arrow points forward (+Z direction after 180 flip)
      const arrowVerts = new Float32Array([
        // Arrow shape pointing forward (nose at front)
        0, 0, 0.5,        // nose (front tip)
        -0.25, 0, -0.3,   // left back corner
        0, 0, -0.15,      // center notch (back)
        
        0, 0, 0.5,        // nose (front tip)
        0, 0, -0.15,      // center notch (back)
        0.25, 0, -0.3,    // right back corner
        
        // Close the back
        -0.25, 0, -0.3,   // left back corner
        0, 0, -0.15,      // center notch
        0.25, 0, -0.3,    // right back corner
      ]);
      
      const arrowGeo = new THREE.BufferGeometry();
      arrowGeo.setAttribute('position', new THREE.BufferAttribute(arrowVerts, 3));
      
      // Wireframe material - retro arcade look
      const wireMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });
      
      const arrow = new THREE.Mesh(arrowGeo, wireMat);
      group.add(arrow);
      
      // Store materials for collision color change
      airplaneMaterials = [wireMat];
      
      // Add edge lines for cleaner wireframe look
      const edgeVerts = new Float32Array([
        // Outline of the arrow
        0, 0, 0.5,        // nose
        -0.25, 0, -0.3,   // left back
        -0.25, 0, -0.3,   // left back
        0, 0, -0.15,      // center notch
        0, 0, -0.15,      // center notch
        0.25, 0, -0.3,    // right back
        0.25, 0, -0.3,    // right back
        0, 0, 0.5,        // back to nose
      ]);
      
      const edgeGeo = new THREE.BufferGeometry();
      edgeGeo.setAttribute('position', new THREE.BufferAttribute(edgeVerts, 3));
      
      const lineMat = new THREE.LineBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 1.0,
        linewidth: 2
      });
      
      const edges = new THREE.LineSegments(edgeGeo, lineMat);
      group.add(edges);
      
      // Add line material to stored materials
      airplaneMaterials.push(lineMat);
      
      // Scale based on airplaneState.size
      group.scale.set(airplaneState.size, airplaneState.size, airplaneState.size);
      
      return group;
    }

    function initAirplane() {
      if (airplaneGroup) {
        scene.remove(airplaneGroup);
        airplaneGroup = null;
      }
      airplaneGroup = createAirplane();
      airplaneGroup.visible = airplaneState.enabled;
      scene.add(airplaneGroup);
    }

    function updateAirplane(delta) {
      if (!airplaneGroup || !airplaneState.enabled) return;
      
      // Handle horizontal input - update target position
      if (keysPressed.left) {
        airplaneState.targetX = Math.max(-airplaneState.maxOffset, airplaneState.targetX - airplaneState.speed * delta);
      }
      if (keysPressed.right) {
        airplaneState.targetX = Math.min(airplaneState.maxOffset, airplaneState.targetX + airplaneState.speed * delta);
      }
      
      // Handle vertical input - update target altitude
      if (keysPressed.up) {
        airplaneState.targetY = Math.min(airplaneState.altitudeRange, airplaneState.targetY + airplaneState.vertSpeed * delta);
      }
      if (keysPressed.down) {
        airplaneState.targetY = Math.max(-airplaneState.altitudeRange, airplaneState.targetY - airplaneState.vertSpeed * delta);
      }
      
      // Smooth horizontal movement toward target
      const dx = airplaneState.targetX - airplaneState.x;
      airplaneState.x += dx * Math.min(1, airplaneState.smoothing * delta);
      
      // Smooth vertical movement toward target
      const dy = airplaneState.targetY - airplaneState.y;
      airplaneState.y += dy * Math.min(1, airplaneState.smoothing * delta);
      
      // Calculate tilt based on movement direction (bank into turns like real airplane)
      const targetTilt = dx * 1.25; // reversed tilt, reduced by 50%
      airplaneState.tilt += (targetTilt - airplaneState.tilt) * Math.min(1, 6 * delta);
      
      // Calculate pitch based on vertical movement
      const targetPitch = -dy * 0.8; // nose up when climbing, down when diving
      airplaneState.pitch += (targetPitch - airplaneState.pitch) * Math.min(1, 6 * delta);
      
      // Position airplane relative to camera
      // Get camera's forward direction on XZ plane
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      // Get right vector
      const right = new THREE.Vector3();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      
      // Position airplane in front of and slightly below camera
      airplaneGroup.position.copy(camera.position);
      airplaneGroup.position.addScaledVector(forward, airplaneState.distance);
      airplaneGroup.position.addScaledVector(right, airplaneState.x);
      airplaneGroup.position.y = camera.position.y + airplaneState.height + airplaneState.y;
      
      // Update scale
      airplaneGroup.scale.set(airplaneState.size, airplaneState.size, airplaneState.size);
      
      // Orient airplane to face camera's forward direction with tilt and pitch
      const lookTarget = airplaneGroup.position.clone().add(forward);
      airplaneGroup.lookAt(lookTarget);
      airplaneGroup.rotation.z = airplaneState.tilt;
      airplaneGroup.rotation.x += airplaneState.pitch;
      
      const time = performance.now() * 0.001;
      
      // Collision detection - sample actual terrain height at airplane position
      const terrainHeight = sampleTerrainHeight(airplaneGroup.position.x, airplaneGroup.position.z);
      
      const wasColliding = airplaneState.isColliding;
      if (terrainHeight !== null) {
        // Compare airplane Y to actual terrain height at this position
        const clearance = airplaneGroup.position.y - terrainHeight;
        airplaneState.isColliding = clearance < airplaneState.collisionThreshold;
      } else {
        airplaneState.isColliding = false; // No heightmap yet
      }
      
      // Handle collision effects
      // Get target colors from uniforms (which are synced with params)
      const dangerColor = pointMaterial.uniforms.uAirplaneColorClose.value;
      const safeColor = pointMaterial.uniforms.uAirplaneColorFar.value;
      
      if (airplaneState.isColliding) {
        // Increase shake intensity
        airplaneState.collisionShake = Math.min(airplaneState.collisionShake + delta * 15, 1.0);
        
        // Turn airplane to danger color
        for (const mat of airplaneMaterials) {
          mat.color.copy(dangerColor);
        }
        
        // Apply shake
        const shakeIntensity = airplaneState.collisionShake * 0.08;
        airplaneGroup.position.x += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.position.y += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.position.z += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.rotation.z += (Math.random() - 0.5) * shakeIntensity * 0.5;
      } else {
        // Decay shake when not colliding
        airplaneState.collisionShake = Math.max(airplaneState.collisionShake - delta * 5, 0);
        
        // Transition to safe color smoothly
        for (const mat of airplaneMaterials) {
          const currentColor = mat.color;
          currentColor.r += (safeColor.r - currentColor.r) * delta * 5;
          currentColor.g += (safeColor.g - currentColor.g) * delta * 5;
          currentColor.b += (safeColor.b - currentColor.b) * delta * 5;
        }
        
        // Add subtle bobbing motion only when not colliding
        airplaneGroup.position.y += Math.sin(time * 2) * 0.02;
      }
    }

    // Keyboard controls for airplane
    window.addEventListener('keydown', (e) => {
      if (!airplaneState.enabled) return;
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        keysPressed.left = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        keysPressed.right = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysPressed.up = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysPressed.down = true;
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        keysPressed.left = false;
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        keysPressed.right = false;
      }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysPressed.up = false;
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysPressed.down = false;
      }
    });

    // Initialize airplane
    initAirplane();

    // ========== POINT CLOUD SYSTEM (FREE & OPEN SOURCE) ==========
    let pointCloudMode = 'heightmap'; // 'heightmap' | 'elevation' | 'ply' | 'las' (LAS/LAZ)
    let extractedPointCloud = null;

    // Create point cloud material for loaded data
    const loadedPointMaterial = new THREE.PointsMaterial({
      size: 0.02,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      sizeAttenuation: true,
    });

    // State for terrain generation
    const terrainState = {
      latitude: 45.8326,   // Mont Blanc area (free elevation data available)
      longitude: 6.8652,
      gridSize: 50,        // Grid points per side
      areaSize: 0.05,      // Area in degrees (~5km)
      heightScale: 0.001,  // Scale elevation to scene units
      isLoading: false,
    };

    // Preset locations with good free elevation data
    const presetLocations = {
      'Mont Blanc (Alps)': { lat: 45.8326, lon: 6.8652, area: 0.05 },
      'Grand Canyon': { lat: 36.1069, lon: -112.1129, area: 0.08 },
      'Mount Fuji': { lat: 35.3606, lon: 138.7274, area: 0.06 },
      'Yosemite Valley': { lat: 37.7456, lon: -119.5936, area: 0.04 },
      'Swiss Alps (Matterhorn)': { lat: 45.9766, lon: 7.6585, area: 0.05 },
      'Norwegian Fjords': { lat: 62.1167, lon: 6.7500, area: 0.06 },
      'Himalaya (Everest region)': { lat: 27.9881, lon: 86.9250, area: 0.08 },
    };

    // Links to free LiDAR datasets
    const freeLiDARDatasets = {
      'USGS 3DEP (USA)': 'https://apps.nationalmap.gov/lidar-explorer/',
      'AHN Netherlands': 'https://www.ahn.nl/ahn-viewer',
      'UK Environment Agency': 'https://environment.data.gov.uk/DefraDataDownload/?Mode=survey',
      'OpenTopography': 'https://portal.opentopography.org/dataCatalog',
      'Spain PNOA': 'https://centrodedescargas.cnig.es/CentroDescargas/',
    };

    // ========== OPEN-ELEVATION API (FREE, NO KEY) ==========
    async function generateTerrainFromElevation() {
      if (terrainState.isLoading) return;
      terrainState.isLoading = true;

      const { latitude, longitude, gridSize, areaSize, heightScale } = terrainState;
      const halfArea = areaSize / 2;

      // Generate grid of lat/lon points
      const locations = [];
      for (let z = 0; z < gridSize; z++) {
        for (let x = 0; x < gridSize; x++) {
          const lat = latitude - halfArea + (z / (gridSize - 1)) * areaSize;
          const lon = longitude - halfArea + (x / (gridSize - 1)) * areaSize;
          locations.push({ latitude: lat, longitude: lon });
        }
      }

      try {
        // Open-Elevation API - free, no key required
        // Limit: batch requests in chunks of 100
        const chunkSize = 100;
        const elevations = [];

        for (let i = 0; i < locations.length; i += chunkSize) {
          const chunk = locations.slice(i, i + chunkSize);
          const response = await fetch('https://api.open-elevation.com/api/v1/lookup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: chunk })
          });

          if (!response.ok) throw new Error(`API error: ${response.status}`);

          const data = await response.json();
          elevations.push(...data.results.map(r => r.elevation));

          // Rate limiting
          if (i + chunkSize < locations.length) {
            await new Promise(r => setTimeout(r, 1100)); // 1 request/second limit
          }
        }

        // Create point cloud from elevation data
        const positions = [];
        const colors = [];
        let minElev = Infinity, maxElev = -Infinity;

        // Find elevation range for coloring
        for (const e of elevations) {
          if (e < minElev) minElev = e;
          if (e > maxElev) maxElev = e;
        }
        const elevRange = maxElev - minElev || 1;

        // Generate points
        const sceneSize = 10; // Scene units
        for (let z = 0; z < gridSize; z++) {
          for (let x = 0; x < gridSize; x++) {
            const idx = z * gridSize + x;
            const elev = elevations[idx];

            // Position in scene
            const px = (x / (gridSize - 1) - 0.5) * sceneSize;
            const pz = (z / (gridSize - 1) - 0.5) * sceneSize;
            const py = (elev - minElev) * heightScale;

            positions.push(px, py, pz);

            // Color based on elevation (green low, brown mid, white high)
            const t = (elev - minElev) / elevRange;
            if (t < 0.3) {
              colors.push(0.2 + t, 0.5 + t * 0.5, 0.2);
            } else if (t < 0.7) {
              colors.push(0.5 + (t - 0.3) * 0.5, 0.4 + (t - 0.3) * 0.3, 0.2);
            } else {
              colors.push(0.8 + (t - 0.7) * 0.6, 0.8 + (t - 0.7) * 0.6, 0.8 + (t - 0.7) * 0.6);
            }
          }
        }

        // Create geometry
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.computeBoundingSphere();

        // Clear existing and add new
        disposePointCloud();
        extractedPointCloud = new THREE.Points(geometry, loadedPointMaterial);
        extractedPointCloud.frustumCulled = false;
        scene.add(extractedPointCloud);

        // Hide heightmap tiles
        for (const p of tilesPoints) p.visible = false;

        console.log(`Terrain generated: ${positions.length / 3} points, elevation ${minElev.toFixed(0)}m - ${maxElev.toFixed(0)}m`);

      } catch (err) {
        console.error('Failed to fetch elevation data:', err);
        alert('Erreur lors du chargement des données d\'élévation: ' + err.message);
      } finally {
        terrainState.isLoading = false;
      }
    }

    function disposePointCloud() {
      if (extractedPointCloud) {
        scene.remove(extractedPointCloud);
        if (extractedPointCloud.geometry) extractedPointCloud.geometry.dispose();
        extractedPointCloud = null;
      }
    }

    // ========== PLY POINT CLOUD LOADER ==========
    async function loadPLYFile(file) {
      const text = await file.text();
      const lines = text.split('\n');

      let headerEnd = 0;
      let vertexCount = 0;
      let hasColor = false;

      // Parse header
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === 'end_header') {
          headerEnd = i + 1;
          break;
        }
        if (line.startsWith('element vertex')) {
          vertexCount = parseInt(line.split(' ')[2]);
        }
        if (line.startsWith('property') && (line.includes('red') || line.includes('r '))) {
          hasColor = true;
        }
      }

      const positions = [];
      const colors = [];

      // Parse vertices
      for (let i = 0; i < vertexCount && (headerEnd + i) < lines.length; i++) {
        const line = lines[headerEnd + i].trim();
        if (!line) continue;

        const parts = line.split(/\s+/);
        if (parts.length >= 3) {
          positions.push(parseFloat(parts[0]), parseFloat(parts[1]), parseFloat(parts[2]));

          if (hasColor && parts.length >= 6) {
            colors.push(parseFloat(parts[3]) / 255, parseFloat(parts[4]) / 255, parseFloat(parts[5]) / 255);
          } else {
            colors.push(0.8, 0.8, 0.8);
          }
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeBoundingSphere();
      geometry.computeBoundingBox();

      // Center and scale the point cloud
      const center = new THREE.Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);

      // Scale to fit in scene
      const size = geometry.boundingBox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 10 / maxDim;  // Fit in ~10 unit box
      geometry.scale(scale, scale, scale);

      return geometry;
    }

    // ========== LAS FILE LOADER (Uncompressed LiDAR) ==========
    async function loadLASFile(file) {
      const buffer = await file.arrayBuffer();
      const view = new DataView(buffer);

      // Check signature "LASF"
      const signature = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));
      if (signature !== 'LASF') {
        throw new Error('Invalid LAS file (signature mismatch)');
      }

      // Read header
      const versionMajor = view.getUint8(24);
      const versionMinor = view.getUint8(25);
      const headerSize = view.getUint16(94, true);
      const offsetToPoints = view.getUint32(96, true);
      const pointFormat = view.getUint8(104);
      const pointRecordLength = view.getUint16(105, true);
      const numPoints = view.getUint32(107, true);

      // Scale and offset for coordinates
      const scaleX = view.getFloat64(131, true);
      const scaleY = view.getFloat64(139, true);
      const scaleZ = view.getFloat64(147, true);
      const offsetX = view.getFloat64(155, true);
      const offsetY = view.getFloat64(163, true);
      const offsetZ = view.getFloat64(171, true);

      console.log(`LAS ${versionMajor}.${versionMinor}, Format ${pointFormat}, ${numPoints} points`);

      const positions = [];
      const colors = [];
      const hasRGB = pointFormat === 2 || pointFormat === 3 || pointFormat === 5 || pointFormat === 7;

      // Read points (limit for performance)
      const maxPoints = Math.min(numPoints, 2000000);
      const step = Math.max(1, Math.floor(numPoints / maxPoints));

      for (let i = 0; i < numPoints; i += step) {
        const offset = offsetToPoints + i * pointRecordLength;
        if (offset + 20 > buffer.byteLength) break;

        // Read XYZ as int32
        const xi = view.getInt32(offset, true);
        const yi = view.getInt32(offset + 4, true);
        const zi = view.getInt32(offset + 8, true);

        const x = xi * scaleX + offsetX;
        const y = yi * scaleY + offsetY;
        const z = zi * scaleZ + offsetZ;

        positions.push(x, z, -y); // Swap Y/Z for Three.js

        // Read RGB if available
        if (hasRGB && offset + 28 <= buffer.byteLength) {
          const rgbOffset = pointFormat === 2 ? 20 : 28;
          const r = view.getUint16(offset + rgbOffset, true) / 65535;
          const g = view.getUint16(offset + rgbOffset + 2, true) / 65535;
          const b = view.getUint16(offset + rgbOffset + 4, true) / 65535;
          colors.push(r, g, b);
        } else {
          // Use intensity for grayscale
          const intensity = view.getUint16(offset + 12, true) / 65535;
          colors.push(intensity, intensity, intensity);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeBoundingSphere();
      geometry.computeBoundingBox();

      // Center and scale
      const center = new THREE.Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);

      const size = geometry.boundingBox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 10 / maxDim;
      geometry.scale(scale, scale, scale);

      return geometry;
    }

    function buildLidarGeometry(positions, colors, intensities) {
      const pointCount = Math.floor(positions.length / 3);
      const maxPoints = 2000000;
      const step = Math.max(1, Math.floor(pointCount / maxPoints));
      const sampledCount = Math.ceil(pointCount / step);

      const sampledPositions = new Float32Array(sampledCount * 3);
      const sampledColors = new Float32Array(sampledCount * 3);
      const hasColors = colors && colors.length >= pointCount * 4;
      const hasIntensity = !hasColors && intensities && intensities.length >= pointCount;

      let writeIndex = 0;
      for (let i = 0; i < pointCount; i += step) {
        const base = i * 3;
        const x = positions[base];
        const y = positions[base + 1];
        const z = positions[base + 2];
        sampledPositions[writeIndex * 3] = x;
        sampledPositions[writeIndex * 3 + 1] = z;
        sampledPositions[writeIndex * 3 + 2] = -y;

        if (hasColors) {
          const colorBase = i * 4;
          sampledColors[writeIndex * 3] = colors[colorBase] / 255;
          sampledColors[writeIndex * 3 + 1] = colors[colorBase + 1] / 255;
          sampledColors[writeIndex * 3 + 2] = colors[colorBase + 2] / 255;
        } else if (hasIntensity) {
          const intensity = intensities[i] / 65535;
          sampledColors[writeIndex * 3] = intensity;
          sampledColors[writeIndex * 3 + 1] = intensity;
          sampledColors[writeIndex * 3 + 2] = intensity;
        } else {
          sampledColors[writeIndex * 3] = 0.8;
          sampledColors[writeIndex * 3 + 1] = 0.8;
          sampledColors[writeIndex * 3 + 2] = 0.8;
        }

        writeIndex += 1;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(sampledPositions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(sampledColors, 3));
      geometry.computeBoundingSphere();
      geometry.computeBoundingBox();

      // Center and scale
      const center = new THREE.Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);

      const size = geometry.boundingBox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const scale = 10 / maxDim;
      geometry.scale(scale, scale, scale);

      return geometry;
    }

    async function loadLAZFile(file) {
      const buffer = await file.arrayBuffer();
      const lasMesh = await load(buffer, LASLoader);
      const positions = lasMesh?.attributes?.POSITION?.value;
      if (!positions) {
        throw new Error('No point positions found in LAZ file.');
      }
      const colors = lasMesh?.attributes?.COLOR_0?.value;
      const intensities = lasMesh?.attributes?.intensity?.value;
      return buildLidarGeometry(positions, colors, intensities);
    }

    async function loadLidarFile(file) {
      const fileName = file.name.toLowerCase();
      if (fileName.endsWith('.laz')) {
        return loadLAZFile(file);
      }
      return loadLASFile(file);
    }

    // Tiling with Points
    let tilesPoints = [];
    const state = { tileSize: initialSize, tilesX: 3, tilesZ: 3, scrollSpeed: 3 };
    const scrollOffset = new THREE.Vector2(0, 0);

    function buildBaseGeometry() {
      const g = new THREE.PlaneGeometry(state.tileSize, state.tileSize, segments, segments);
      g.rotateX(-Math.PI / 2);
      return g;
    }

    function positiveModulo(v, m) { return ((v % m) + m) % m; }

    function updateTileMatrices() {
      if (!tilesPoints || tilesPoints.length === 0) return;
      let idx = 0;
      const offsetX = (state.tilesX - 1) * state.tileSize * 0.5;
      const offsetZ = (state.tilesZ - 1) * state.tileSize * 0.5;
      const modX = positiveModulo(scrollOffset.x, state.tileSize);
      const modZ = positiveModulo(scrollOffset.y, state.tileSize);
      for (let z = 0; z < state.tilesZ; z++) {
        for (let x = 0; x < state.tilesX; x++) {
          const px = (x * state.tileSize) - offsetX - modX;
          const pz = (z * state.tileSize) - offsetZ - modZ;
          const pts = tilesPoints[idx++];
          if (pts) pts.position.set(px, 0, pz);
        }
      }
    }

    function rebuildTiling() {
      if (tilesPoints && tilesPoints.length) {
        for (const p of tilesPoints) {
          scene.remove(p);
          if (p.geometry) p.geometry.dispose();
        }
      }
      tilesPoints = [];
      const geometry = buildBaseGeometry();
      geometry.deleteAttribute('normal');
      geometry.deleteAttribute('tangent');
      // Ensure each vertex becomes a point; PlaneGeometry already has indexed triangles.
      // Convert to non-indexed so every vertex is unique for gl.POINTS
      const nonIndexed = geometry.toNonIndexed();
      nonIndexed.computeBoundingSphere();
      for (let z = 0; z < state.tilesZ; z++) {
        for (let x = 0; x < state.tilesX; x++) {
          const pts = new THREE.Points(nonIndexed, pointMaterial);
          pts.frustumCulled = false;
          tilesPoints.push(pts);
          scene.add(pts);
        }
      }
      updateTileMatrices();
    }

    rebuildTiling();

    // (Car and follower removed)

    // (CPU height sampling removed)

    // (Cursor/mouse following removed)

    // UI elements
    const fileInput = document.getElementById('heightmapFile');

    // Tweakpane setup
    const pane = new Pane({ title: 'Particle Landscape' });
    
    // Parameters object
    const params = {
      // Heightmap
      terrainColor: '#8a8f9a',
      scale: 1.4,
      tileSize: 11,
      tilesX: 1,
      tilesZ: 3,
      // Particles
      pointSize: 0.01,
      jitter: 0.02,
      hoverRadius: 1.6,
      hoverStrength: 0.8,
      hoverSnap: 2.0,
      hoverColor: '#ffcc55',
      cols: 416,
      rows: 416,
      // Mask
      maskRadius: 3.0,
      maskFeather: 0.8,
      // Animation
      scrollSpeed: 0.6,
      animateScroll: true,
      // Camera
      camYaw: 0,
      camPitch: -41,
      camFov: 90,
      camHeight: 3.0,
      camZ: 5.4,
      // Fog
      fogEnabled: true,
      fogColor: '#0e0f13',
      fogNear: 12,
      fogFar: 1,
      // Airplane
      airplaneEnabled: false,
      airplaneSpeed: 3,
      airplaneMaxOffset: 5.5,
      airplaneVertSpeed: 2,
      airplaneAltitudeRange: 1.5,
      airplaneHeight: -2.5,
      airplaneSize: 0.4,
      airplaneDistance: 3.5,
      // Hover highlights
      mouseHoverEnabled: true,
      airplaneHoverEnabled: true,
      airplaneHoverRadius: 2.0,
      airplaneColorSafe: '#00ffaa',   // cyan-green when high/safe
      airplaneColorDanger: '#ff0000', // red when low/danger
    };

    // Helper functions
    const degToRad = (d) => d * Math.PI / 180;
    const clampPitchDeg = (p) => Math.max(-89, Math.min(89, p));
    function applyYawPitchDeg(yawDeg, pitchDeg) {
      const yaw = degToRad(yawDeg);
      const pitch = degToRad(clampPitchDeg(pitchDeg));
      const e = new THREE.Euler(pitch, yaw, 0, 'YXZ');
      camera.quaternion.setFromEuler(e);
    }

    function clampPowerOfTwo(n) {
      return Math.max(2, Math.min(2048, Math.floor(n)));
    }

    function applyFogFromParams() {
      if (params.fogEnabled) {
        scene.fog = new THREE.Fog(
          params.fogColor, 
          Math.min(params.fogNear, params.fogFar - 0.001), 
          Math.max(params.fogNear + 0.001, params.fogFar)
        );
        scene.background = new THREE.Color(params.fogColor);
      } else {
        scene.fog = null;
      }
    }

    // Point Cloud Source folder
    const sourceFolder = pane.addFolder({ title: 'Point Cloud Source', expanded: true });
    const sourceParams = {
      mode: 'heightmap',
      presetLocation: 'Mont Blanc (Alps)',
    };

    sourceFolder.addBinding(sourceParams, 'mode', {
      label: 'Source',
      options: {
        'Heightmap': 'heightmap',
        'Free Elevation API': 'elevation',
        'PLY File': 'ply',
        'LAS/LAZ File': 'las',
      }
    }).on('change', (ev) => {
      pointCloudMode = ev.value;
      updateSourceVisibility();
    });

    // Free Elevation API subfolder (Open-Elevation - 100% gratuit)
    const elevationFolder = sourceFolder.addFolder({ title: 'Free Elevation API', expanded: true });

    elevationFolder.addBinding(sourceParams, 'presetLocation', {
      label: 'Preset',
      options: Object.fromEntries(Object.keys(presetLocations).map(k => [k, k]))
    }).on('change', (ev) => {
      const loc = presetLocations[ev.value];
      if (loc) {
        terrainState.latitude = loc.lat;
        terrainState.longitude = loc.lon;
        terrainState.areaSize = loc.area;
        pane.refresh();
      }
    });

    elevationFolder.addBinding(terrainState, 'latitude', { label: 'Latitude', min: -90, max: 90, step: 0.0001 });
    elevationFolder.addBinding(terrainState, 'longitude', { label: 'Longitude', min: -180, max: 180, step: 0.0001 });
    elevationFolder.addBinding(terrainState, 'areaSize', { label: 'Zone (deg)', min: 0.01, max: 0.2, step: 0.01 });
    elevationFolder.addBinding(terrainState, 'gridSize', { label: 'Resolution', min: 20, max: 100, step: 10 });
    elevationFolder.addBinding(terrainState, 'heightScale', { label: 'Height Scale', min: 0.0001, max: 0.01, step: 0.0001 });

    elevationFolder.addBlade({ view: 'separator' });

    elevationFolder.addButton({ title: 'Generate Terrain (Free API)' }).on('click', async () => {
      if (terrainState.isLoading) {
        alert('Loading in progress...');
        return;
      }
      await generateTerrainFromElevation();
    });

    elevationFolder.addButton({ title: 'Clear & Show Heightmap' }).on('click', () => {
      disposePointCloud();
      for (const p of tilesPoints) p.visible = true;
      pointCloudMode = 'heightmap';
      sourceParams.mode = 'heightmap';
      pane.refresh();
    });

    // Free LiDAR datasets info
    const datasetsFolder = sourceFolder.addFolder({ title: 'Free LiDAR Datasets', expanded: false });

    for (const [name, url] of Object.entries(freeLiDARDatasets)) {
      datasetsFolder.addButton({ title: name }).on('click', () => {
        window.open(url, '_blank');
      });
    }

    // PLY file loader
    const plyFolder = sourceFolder.addFolder({ title: 'PLY File', expanded: false });
    const plyFileInput = document.createElement('input');
    plyFileInput.type = 'file';
    plyFileInput.accept = '.ply';
    plyFileInput.style.display = 'none';
    document.body.appendChild(plyFileInput);

    plyFolder.addButton({ title: 'Load PLY File...' }).on('click', () => {
      plyFileInput.click();
    });

    plyFileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      try {
        const geometry = await loadPLYFile(file);
        disposePointCloud();
        for (const p of tilesPoints) p.visible = false;
        extractedPointCloud = new THREE.Points(geometry, loadedPointMaterial);
        extractedPointCloud.frustumCulled = false;
        scene.add(extractedPointCloud);

        console.log('PLY loaded:', geometry.getAttribute('position').count, 'points');
      } catch (err) {
        console.error('Failed to load PLY file:', err);
        alert('Failed to load PLY file: ' + err.message);
      }
    });

    // LAS file loader
    const lasFolder = sourceFolder.addFolder({ title: 'LAS/LAZ File (LiDAR)', expanded: false });
    const lasFileInput = document.createElement('input');
    lasFileInput.type = 'file';
    lasFileInput.accept = '.las,.laz';
    lasFileInput.style.display = 'none';
    document.body.appendChild(lasFileInput);

    lasFolder.addButton({ title: 'Load LAS/LAZ File...' }).on('click', () => {
      lasFileInput.click();
    });

    lasFileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      try {
        const geometry = await loadLidarFile(file);
        disposePointCloud();
        for (const p of tilesPoints) p.visible = false;
        extractedPointCloud = new THREE.Points(geometry, loadedPointMaterial);
        extractedPointCloud.frustumCulled = false;
        scene.add(extractedPointCloud);

        console.log('LAS/LAZ loaded:', geometry.getAttribute('position').count, 'points');
      } catch (err) {
        console.error('Failed to load LAS/LAZ file:', err);
        alert('Erreur LAS/LAZ: ' + err.message);
      }
    });

    function updateSourceVisibility() {
      elevationFolder.hidden = pointCloudMode !== 'elevation';
      plyFolder.hidden = pointCloudMode !== 'ply';
      lasFolder.hidden = pointCloudMode !== 'las';
      datasetsFolder.hidden = pointCloudMode !== 'ply' && pointCloudMode !== 'las';

      if (pointCloudMode === 'heightmap') {
        // Show heightmap tiles, hide extracted point cloud
        for (const p of tilesPoints) p.visible = true;
        if (extractedPointCloud) extractedPointCloud.visible = false;
      } else if (pointCloudMode === 'elevation') {
        // Will show when generated
      } else if (pointCloudMode === 'ply' || pointCloudMode === 'las') {
        // File mode - hide heightmap
        for (const p of tilesPoints) p.visible = false;
        if (extractedPointCloud) extractedPointCloud.visible = true;
      }
    }

    // Initialize visibility
    updateSourceVisibility();

    sourceFolder.addBlade({ view: 'separator' });

    // Heightmap folder
    const heightmapFolder = pane.addFolder({ title: 'Heightmap', expanded: true });
    heightmapFolder.addButton({ title: 'Load Heightmap...' }).on('click', () => {
      fileInput.click();
    });
    heightmapFolder.addBinding(params, 'terrainColor', { view: 'color' }).on('change', (ev) => {
      pointMaterial.uniforms.uColor.value.set(ev.value);
    });
    heightmapFolder.addBinding(params, 'scale', { min: 0, max: 8, step: 0.1 }).on('change', (ev) => {
      pointMaterial.uniforms.uScale.value = ev.value;
      pointMaterial.uniforms.uBias.value = -ev.value * 0.5;
    });
    heightmapFolder.addBinding(params, 'tileSize', { min: 2, max: 50, step: 1 }).on('change', (ev) => {
      state.tileSize = Math.max(1, ev.value);
      rebuildTiling();
    });
    heightmapFolder.addBinding(params, 'tilesX', { min: 1, max: 20, step: 1 }).on('change', (ev) => {
      state.tilesX = Math.max(1, Math.min(20, ev.value));
      rebuildTiling();
    });
    heightmapFolder.addBinding(params, 'tilesZ', { min: 1, max: 20, step: 1 }).on('change', (ev) => {
      state.tilesZ = Math.max(1, Math.min(20, ev.value));
      rebuildTiling();
    });

    // Particles folder
    const particlesFolder = pane.addFolder({ title: 'Particles', expanded: true });
    particlesFolder.addBinding(params, 'pointSize', { min: 0, max: 0.5, step: 0.01, label: 'Point Size' }).on('change', (ev) => {
      pointMaterial.uniforms.uPointSize.value = ev.value;
    });
    particlesFolder.addBinding(params, 'jitter', { min: 0.0, max: 0.2, step: 0.001 }).on('change', (ev) => {
      pointMaterial.uniforms.uJitter.value = ev.value;
    });
    particlesFolder.addBlade({ view: 'separator' });
    particlesFolder.addBinding(params, 'hoverRadius', { min: 0.1, max: 10, step: 0.1, label: 'Hover Radius' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverRadius.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverStrength', { min: 0, max: 10, step: 0.1, label: 'Hover Strength' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverStrength.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverSnap', { min: 0.1, max: 10, step: 0.1, label: 'Hover Snap' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverSnap.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverColor', { view: 'color', label: 'Hover Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverColor.value.set(ev.value);
    });
    particlesFolder.addBinding(params, 'mouseHoverEnabled', { label: 'Mouse Hover' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverEnabled.value = ev.value ? 1.0 : 0.0;
    });
    particlesFolder.addBlade({ view: 'separator' });
    particlesFolder.addBinding(params, 'cols', { min: 8, max: 1024, step: 8 }).on('change', (ev) => {
      params.cols = clampPowerOfTwo(ev.value);
      segments = Math.max(2, Math.max(params.cols, params.rows));
      rebuildTiling();
    });
    particlesFolder.addBinding(params, 'rows', { min: 8, max: 1024, step: 8 }).on('change', (ev) => {
      params.rows = clampPowerOfTwo(ev.value);
      segments = Math.max(2, Math.max(params.cols, params.rows));
      rebuildTiling();
    });

    // Mask folder
    const maskFolder = pane.addFolder({ title: 'Mask', expanded: true });
    maskFolder.addBinding(params, 'maskRadius', { min: 0.1, max: 20, step: 0.1, label: 'Mask Radius' }).on('change', (ev) => {
      pointMaterial.uniforms.uMaskRadius.value = ev.value;
    });
    maskFolder.addBinding(params, 'maskFeather', { min: 0.0, max: 5, step: 0.1, label: 'Mask Feather' }).on('change', (ev) => {
      pointMaterial.uniforms.uMaskFeather.value = ev.value;
    });

    // Animation folder
    const animationFolder = pane.addFolder({ title: 'Animation', expanded: true });
    animationFolder.addBinding(params, 'scrollSpeed', { min: -20, max: 20, step: 0.1, label: 'Scroll Speed' }).on('change', (ev) => {
      state.scrollSpeed = ev.value;
    });
    animationFolder.addBinding(params, 'animateScroll', { label: 'Animate' });

    // Airplane folder
    const airplaneFolder = pane.addFolder({ title: 'Airplane', expanded: true });
    airplaneFolder.addBinding(params, 'airplaneEnabled', { label: 'Enable Airplane' }).on('change', (ev) => {
      airplaneState.enabled = ev.value;
      if (airplaneGroup) airplaneGroup.visible = ev.value;
      // Reset position when toggled on
      if (ev.value) {
        airplaneState.x = 0;
        airplaneState.targetX = 0;
        airplaneState.y = 0;
        airplaneState.targetY = 0;
        airplaneState.tilt = 0;
        airplaneState.pitch = 0;
      }
    });
    airplaneFolder.addBinding(params, 'airplaneSpeed', { min: 1, max: 20, step: 0.5, label: 'Move Speed' }).on('change', (ev) => {
      airplaneState.speed = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneMaxOffset', { min: 1, max: 15, step: 0.5, label: 'Max Offset' }).on('change', (ev) => {
      airplaneState.maxOffset = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneVertSpeed', { min: 0.5, max: 5, step: 0.1, label: 'Vert Speed' }).on('change', (ev) => {
      airplaneState.vertSpeed = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneAltitudeRange', { min: 0.5, max: 5, step: 0.1, label: 'Alt Range' }).on('change', (ev) => {
      airplaneState.altitudeRange = ev.value;
    });
    airplaneFolder.addBlade({ view: 'separator' });
    airplaneFolder.addBinding(params, 'airplaneHeight', { min: -5, max: 1, step: 0.1, label: 'Height' }).on('change', (ev) => {
      airplaneState.height = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneSize', { min: 0.2, max: 3, step: 0.1, label: 'Size' }).on('change', (ev) => {
      airplaneState.size = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneDistance', { min: 1, max: 10, step: 0.1, label: 'Distance' }).on('change', (ev) => {
      airplaneState.distance = ev.value;
    });
    airplaneFolder.addBlade({ view: 'separator' });
    airplaneFolder.addBinding(params, 'airplaneHoverEnabled', { label: 'Ground Highlight' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneHoverEnabled.value = ev.value ? 1.0 : 0.0;
    });
    airplaneFolder.addBinding(params, 'airplaneHoverRadius', { min: 0.5, max: 5, step: 0.1, label: 'Highlight Size' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneHoverRadius.value = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneColorSafe', { view: 'color', label: 'Safe Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneColorFar.value.set(ev.value);
    });
    airplaneFolder.addBinding(params, 'airplaneColorDanger', { view: 'color', label: 'Danger Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneColorClose.value.set(ev.value);
    });
    airplaneFolder.addBlade({ view: 'separator' });
    const airplaneHint = airplaneFolder.addBlade({
      view: 'text',
      label: '',
      parse: (v) => String(v),
      value: '↑↓←→ or WASD to fly',
    });
    airplaneHint.disabled = true;

    // Camera folder
    const cameraFolder = pane.addFolder({ title: 'Camera', expanded: true });
    cameraFolder.addBinding(params, 'camYaw', { min: -180, max: 180, step: 1, label: 'Yaw' }).on('change', (ev) => {
      applyYawPitchDeg(ev.value, params.camPitch);
    });
    cameraFolder.addBinding(params, 'camPitch', { min: -89, max: 89, step: 1, label: 'Pitch' }).on('change', (ev) => {
      applyYawPitchDeg(params.camYaw, ev.value);
    });
    cameraFolder.addBinding(params, 'camFov', { min: 20, max: 100, step: 1, label: 'FOV' }).on('change', (ev) => {
      camera.fov = ev.value;
      camera.updateProjectionMatrix();
    });
    cameraFolder.addBinding(params, 'camHeight', { min: 0, max: 100, step: 0.1, label: 'Height' }).on('change', (ev) => {
      camera.position.y = ev.value;
    });
    cameraFolder.addBinding(params, 'camZ', { min: -200, max: 200, step: 0.1, label: 'Camera Z' }).on('change', (ev) => {
      camera.position.z = ev.value;
    });
    cameraFolder.addBlade({ view: 'separator' });
    cameraFolder.addBinding(params, 'fogEnabled', { label: 'Fog Enabled' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogColor', { view: 'color', label: 'Fog Color' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogNear', { min: 0, max: 500, step: 1, label: 'Fog Near' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogFar', { min: 1, max: 1000, step: 1, label: 'Fog Far' }).on('change', applyFogFromParams);
    cameraFolder.addBlade({ view: 'separator' });
    cameraFolder.addButton({ title: 'Reset Camera' }).on('click', () => {
      camera.position.copy(defaultCamPos);
      camera.quaternion.copy(defaultCamQuat);
      const e = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      params.camYaw = Math.round(THREE.MathUtils.radToDeg(e.y));
      params.camPitch = Math.round(THREE.MathUtils.radToDeg(e.x));
      params.camFov = Math.round(camera.fov);
      params.camHeight = camera.position.y;
      params.camZ = camera.position.z;
      pane.refresh();
      scrollOffset.set(0, 0);
      updateTileMatrices();
    });

    // ---- URL parameter configuration ----
    // Allows setting values via query params and optionally hiding the UI
    (function applyUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);

      function setParam(key, paramName) {
        if (urlParams.has(paramName)) {
          const value = urlParams.get(paramName);
          if (typeof params[key] === 'boolean') {
            params[key] = value === '1' || value === 'true' || value === 'on';
        } else {
            params[key] = Number(value) || value;
          }
        }
      }

      // hide UI if ui=0
      if (urlParams.get('ui') === '0') {
        pane.hidden = true;
      }

      // common controls
      setParam('scale', 'scale');
      setParam('tileSize', 'tileSize');
      setParam('tilesX', 'tilesX');
      setParam('tilesZ', 'tilesZ');
      setParam('pointSize', 'psize');
      setParam('maskRadius', 'mask');
      setParam('maskFeather', 'feather');
      setParam('jitter', 'jitter');
      setParam('hoverRadius', 'hR');
      setParam('hoverStrength', 'hS');
      setParam('hoverSnap', 'hSnap');
      setParam('camYaw', 'yaw');
      setParam('camPitch', 'pitch');
      setParam('camFov', 'fov');
      setParam('camHeight', 'height');
      setParam('camZ', 'z');
      setParam('scrollSpeed', 'scroll');
      setParam('animateScroll', 'animate');
      setParam('cols', 'cols');
      setParam('rows', 'rows');
      setParam('fogEnabled', 'fog');
      setParam('fogNear', 'near');
      setParam('fogFar', 'far');
      // colors as hex
      if (urlParams.has('terrain')) {
        params.terrainColor = urlParams.get('terrain');
      }
      if (urlParams.has('fogColor')) {
        params.fogColor = urlParams.get('fogColor');
      }

      // Refresh pane to show URL param values
      pane.refresh();
    })();

    // Initialize camera and scene from param defaults
    (function initFromDefaults() {
      // Apply yaw/pitch
      applyYawPitchDeg(params.camYaw, params.camPitch);
      // Apply FOV
      camera.fov = params.camFov;
      camera.updateProjectionMatrix();
      // Apply height & camera Z
      camera.position.y = params.camHeight;
      camera.position.z = params.camZ;
      // Apply scroll speed
      state.scrollSpeed = params.scrollSpeed;
      // Grid visibility
      grid.visible = false;
      // Scale
      pointMaterial.uniforms.uScale.value = params.scale;
      pointMaterial.uniforms.uBias.value = -params.scale * 0.5;
      // Point color default
      pointMaterial.uniforms.uColor.value.set(params.terrainColor);
      // Jitter default
      pointMaterial.uniforms.uJitter.value = params.jitter;
      // Point defaults
      pointMaterial.uniforms.uPointSize.value = params.pointSize;
      pointMaterial.uniforms.uMaskRadius.value = params.maskRadius;
      pointMaterial.uniforms.uMaskFeather.value = params.maskFeather;
      // Hover defaults
      pointMaterial.uniforms.uHoverRadius.value = params.hoverRadius;
      pointMaterial.uniforms.uHoverStrength.value = params.hoverStrength;
      pointMaterial.uniforms.uHoverSnap.value = params.hoverSnap;
      pointMaterial.uniforms.uHoverColor.value.set(params.hoverColor);
      pointMaterial.uniforms.uHoverEnabled.value = params.mouseHoverEnabled ? 1.0 : 0.0;
      // Airplane hover defaults
      pointMaterial.uniforms.uAirplaneHoverEnabled.value = params.airplaneHoverEnabled ? 1.0 : 0.0;
      pointMaterial.uniforms.uAirplaneHoverRadius.value = params.airplaneHoverRadius;
      
      // Record defaults for Reset
      defaultCamPos = new THREE.Vector3().copy(camera.position);
      defaultCamQuat = new THREE.Quaternion().copy(camera.quaternion);
      // Initialize fog state
      applyFogFromParams();
      // Compile shader after defines updates
      pointMaterial.needsUpdate = true;
      // Load default heightmap texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        DEFAULT_HEIGHTMAP_URL,
        (tex) => {
          applyHeightmapTexture(tex).catch((err) => console.error('Failed to apply default heightmap', err));
        },
        undefined,
        (err) => {
          console.error('Failed to load default heightmap', err);
        }
      );
    })();

    // Static camera: no keyboard/mouse movement

    async function createTextureFromFile(file) {
      try {
        const bitmap = await createImageBitmap(file);
        const texture = new THREE.Texture(bitmap);
        texture.needsUpdate = true;
        return texture;
      } catch (err) {
        const dataUrl = await new Promise((resolve, reject) => {
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = reject;
          fr.readAsDataURL(file);
        });
        const img = await new Promise((resolve, reject) => {
          const i = new Image();
          i.decoding = 'async';
          i.onload = () => resolve(i);
          i.onerror = (e) => reject(e);
          i.src = dataUrl;
        });
        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        return texture;
      }
    }

    let currentHeightmapTexture = null;
    let heightmapCanvas = null;
    let heightmapCtx = null;
    let heightmapWidth = 0;
    let heightmapHeight = 0;

    // Sample terrain height at a world XZ position
    function sampleTerrainHeight(worldX, worldZ) {
      if (!heightmapCtx || !heightmapWidth || !heightmapHeight) {
        return null; // No heightmap loaded yet
      }
      
      const tileSize = state.tileSize;
      
      // Account for scroll offset - the terrain moves, so we need to sample
      // relative to the scrolling position
      const relX = worldX + scrollOffset.x;
      const relZ = worldZ + scrollOffset.y;
      
      // Convert to UV coordinates within [0,1] - the texture repeats per tile
      // Add 0.5 to center the sampling (geometry goes from -tileSize/2 to +tileSize/2)
      let u = (((relX / tileSize) + 0.5) % 1 + 1) % 1;
      let v = (((relZ / tileSize) + 0.5) % 1 + 1) % 1;
      // Flip V because PlaneGeometry rotation may invert it
      v = 1.0 - v;
      
      // Convert UV to pixel coordinates
      const px = Math.floor(u * heightmapWidth);
      const py = Math.floor(v * heightmapHeight);
      
      // Clamp to valid range
      const clampedPx = Math.max(0, Math.min(heightmapWidth - 1, px));
      const clampedPy = Math.max(0, Math.min(heightmapHeight - 1, py));
      
      // Sample the pixel
      const pixelData = heightmapCtx.getImageData(clampedPx, clampedPy, 1, 1).data;
      
      // Calculate height using same formula as shader: (r+g+b)/3 * scale + bias
      const r = pixelData[0] / 255;
      const g = pixelData[1] / 255;
      const b = pixelData[2] / 255;
      const h = (r + g + b) / 3;
      
      const scale = pointMaterial.uniforms.uScale.value;
      const bias = pointMaterial.uniforms.uBias.value;
      
      return h * scale + bias;
    }

    async function applyHeightmapTexture(texture) {
      if (currentHeightmapTexture) {
        currentHeightmapTexture.dispose();
      }
      currentHeightmapTexture = texture;
      texture.colorSpace = THREE.NoColorSpace; // treat as data
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      // NPOT safety: use clamp + no mipmaps; POT can repeat+mips
      const img = texture.image;
      const isPOT = img && ( (img.width & (img.width - 1)) === 0 ) && ( (img.height & (img.height - 1)) === 0 );
      if (isPOT) {
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.generateMipmaps = true;
        texture.minFilter = THREE.LinearMipmapLinearFilter;
      } else {
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
      }
      texture.magFilter = THREE.LinearFilter;
      texture.needsUpdate = true;

      pointMaterial.uniforms.uMap.value = texture;
      pointMaterial.uniforms.uBias.value = -pointMaterial.uniforms.uScale.value * 0.5;
      pointMaterial.needsUpdate = true;
      rebuildTiling();
      
      // Create canvas for CPU-side heightmap sampling
      const texImg = texture.image;
      if (texImg) {
        heightmapWidth = texImg.width || texImg.naturalWidth || 512;
        heightmapHeight = texImg.height || texImg.naturalHeight || 512;
        heightmapCanvas = document.createElement('canvas');
        heightmapCanvas.width = heightmapWidth;
        heightmapCanvas.height = heightmapHeight;
        heightmapCtx = heightmapCanvas.getContext('2d', { willReadFrequently: true });
        heightmapCtx.drawImage(texImg, 0, 0, heightmapWidth, heightmapHeight);
      }
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      try {
        const texture = await createTextureFromFile(file);
        await applyHeightmapTexture(texture);
        console.log('Heightmap loaded:', file.name);
      } catch (err) {
        console.error('Failed to load heightmap texture', err);
      }
    });

    async function handleDropFile(file) {
      if (!file) return;
      const fileName = file.name.toLowerCase();

      // Handle PLY files
      if (fileName.endsWith('.ply')) {
        try {
          const geometry = await loadPLYFile(file);
          disposePointCloud();
          for (const p of tilesPoints) p.visible = false;
          extractedPointCloud = new THREE.Points(geometry, loadedPointMaterial);
          extractedPointCloud.frustumCulled = false;
          scene.add(extractedPointCloud);

          pointCloudMode = 'ply';
          sourceParams.mode = 'ply';
          pane.refresh();
          updateSourceVisibility();

          console.log('PLY loaded via drop:', geometry.getAttribute('position').count, 'points');
        } catch (err) {
          console.error('Failed to load PLY file:', err);
          alert('Erreur PLY: ' + err.message);
        }
        return;
      }

      // Handle LAS/LAZ files
      if (fileName.endsWith('.las') || fileName.endsWith('.laz')) {
        try {
          const geometry = await loadLidarFile(file);
          disposePointCloud();
          for (const p of tilesPoints) p.visible = false;
          extractedPointCloud = new THREE.Points(geometry, loadedPointMaterial);
          extractedPointCloud.frustumCulled = false;
          scene.add(extractedPointCloud);

          pointCloudMode = 'las';
          sourceParams.mode = 'las';
          pane.refresh();
          updateSourceVisibility();

          console.log('LAS/LAZ loaded via drop:', geometry.getAttribute('position').count, 'points');
        } catch (err) {
          console.error('Failed to load LAS/LAZ file:', err);
          alert('Erreur LAS/LAZ: ' + err.message);
        }
        return;
      }

      // Handle image files (heightmaps)
      if (!file.type.startsWith('image/')) return;
      try {
        const texture = await createTextureFromFile(file);
        await applyHeightmapTexture(texture);
        pointCloudMode = 'heightmap';
        sourceParams.mode = 'heightmap';
        pane.refresh();
        updateSourceVisibility();
      } catch (err) {
        console.error('Failed to load dropped heightmap', err);
      }
    }

    renderer.domElement.addEventListener('dragover', (e) => {
      e.preventDefault();
      renderer.domElement.classList.add('drag-over');
    });

    renderer.domElement.addEventListener('dragleave', () => {
      renderer.domElement.classList.remove('drag-over');
    });

    renderer.domElement.addEventListener('drop', (e) => {
      e.preventDefault();
      renderer.domElement.classList.remove('drag-over');
      const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) {
        handleDropFile(file);
      }
    });

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      pointMaterial.uniforms.uTime.value = performance.now() * 0.001;
      // Update hover center from mouse ray on ground plane
      // reuse a simple ray each frame based on last mouse NDC
      if (!window.__raycaster) window.__raycaster = new THREE.Raycaster();
      if (!window.__mouseNdc) window.__mouseNdc = new THREE.Vector2(-2, -2);
      const ray = window.__raycaster;
      ray.setFromCamera(window.__mouseNdc, camera);
      const hit = new THREE.Vector3();
      const ground = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      if (ray.ray.intersectPlane(ground, hit)) {
        pointMaterial.uniforms.uHoverCenter.value.set(hit.x, hit.z);
      } else {
        pointMaterial.uniforms.uHoverCenter.value.set(9999.0, 9999.0);
      }
      if (params.animateScroll && tilesPoints && tilesPoints.length) {
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        if (forward.lengthSq() < 1e-6) forward.set(0, 0, -1);
        forward.normalize();
        const step = state.scrollSpeed * delta;
        scrollOffset.x += forward.x * step;
        scrollOffset.y += forward.z * step;
        updateTileMatrices();
      }
      // Update airplane
      updateAirplane(delta);
      // Update airplane hover position for shader
      if (airplaneGroup && airplaneState.enabled) {
        pointMaterial.uniforms.uAirplanePos.value.copy(airplaneGroup.position);
      } else {
        pointMaterial.uniforms.uAirplanePos.value.set(9999, 9999, 9999);
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
