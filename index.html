<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Three.js Point Cloud Viewer - Heightmaps, Google 3D Tiles & PLY</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0e0f13; color: #e6e6e6; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #overlayInfo {
      position: fixed;
      bottom: 12px;
      left: 12px;
      font-size: 12px;
      color: #b0b5bd;
      background: rgba(20, 22, 28, 0.75);
      padding: 6px 10px;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      z-index: 10;
    }
    #overlayInfo a {
      color: #9bd;
    }
    canvas.drop-target {
      display: block;
      width: 100vw;
      height: 100vh;
      outline: 1px solid transparent;
      transition: outline-color 0.2s ease;
    }
    canvas.drop-target.drag-over {
      outline: 2px dashed rgba(155, 187, 221, 0.85);
    }
    a, a:visited { color: #9bd; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div id="overlayInfo">Drag a heightmap or PLY file onto the canvas. Supports Google 3D Tiles for real-world locations. Project by <a href="https://x.com/taylor_sntx" target="_blank" rel="noopener">Taylor</a></div>
  <input id="heightmapFile" type="file" accept="image/png,image/jpeg,image/webp" style="display:none;">

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/",
        "tweakpane": "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.js",
        "3d-tiles-renderer": "https://cdn.jsdelivr.net/npm/3d-tiles-renderer@0.4.19/src/index.js",
        "3d-tiles-renderer/plugins": "https://cdn.jsdelivr.net/npm/3d-tiles-renderer@0.4.19/src/plugins/index.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { Pane } from 'tweakpane';
    import { TilesRenderer, GlobeControls, EnvironmentControls } from '3d-tiles-renderer';
    import { GoogleCloudAuthPlugin, GLTFExtensionsPlugin, TileCompressionPlugin, UpdateOnChangePlugin, UnloadTilesPlugin } from '3d-tiles-renderer/plugins';

    const DEFAULT_HEIGHTMAP_URL = 'assets/heightmap_512x512.png';
    // Track mouse for hover effects
    window.__mouseNdc = new THREE.Vector2(-2, -2);
    window.addEventListener('mousemove', (e) => {
      window.__mouseNdc.x = (e.clientX / window.innerWidth) * 2 - 1;
      window.__mouseNdc.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0f13);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 18);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    renderer.domElement.classList.add('drop-target');

    const clock = new THREE.Clock();
    const initialCamPos = new THREE.Vector3().copy(camera.position);
    const initialCamQuat = new THREE.Quaternion().copy(camera.quaternion);
    let defaultCamPos;
    let defaultCamQuat;
    

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // Ground grid for scale reference
    const grid = new THREE.GridHelper(200, 200, 0x33353a, 0x1e2026);
    grid.material.opacity = 0.35;
    grid.material.transparent = true;
    grid.material.depthWrite = false;
    grid.material.depthTest = false;
    grid.visible = false;
    scene.add(grid);

    // Plane setup
    const initialSize = 12; // default tile size
    let segments = 256; // will be controlled by UI (subdivisions)

    let plane = null; // unused after tiling in pointcloud mode
    const pointMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uMap: { value: null },
        uScale: { value: 2.8 },
        uBias: { value: -2.8 * 0.5 },
        uColor: { value: new THREE.Color(0x8a8f9a) },
        uPointSize: { value: 2.0 },
        uTime: { value: 0.0 },
        uJitter: { value: 0.02 },
        uMaskCenter: { value: new THREE.Vector2(0.0, 0.0) },
        uMaskRadius: { value: 4.0 },
        uMaskFeather: { value: 0.6 },
        uHoverCenter: { value: new THREE.Vector2(9999.0, 9999.0) },
        uHoverRadius: { value: 1.6 },
        uHoverStrength: { value: 0.8 },
        uHoverSnap: { value: 2.0 },
        uHoverColor: { value: new THREE.Color(0xffcc55) },
        uHoverEnabled: { value: 1.0 },
        // Airplane hover highlight
        uAirplanePos: { value: new THREE.Vector3(9999, 9999, 9999) },
        uAirplaneHoverEnabled: { value: 0.0 },
        uAirplaneHoverRadius: { value: 2.0 },
        uAirplaneColorFar: { value: new THREE.Color(0x00ffaa) },  // cyan-green when high/safe
        uAirplaneColorClose: { value: new THREE.Color(0xff0000) }, // pure red when low/danger
        // Fog uniforms expected by renderer when material.fog === true
        fogColor: { value: new THREE.Color(0x0e0f13) },
        fogNear: { value: 1 },
        fogFar: { value: 1000 },
        fogDensity: { value: 0.00025 }
      },
      transparent: true,
      depthWrite: true,
      blending: THREE.NormalBlending,
      fog: false,
      vertexShader: `
        #include <uv_pars_vertex>
        varying float vMaskAlpha;
        varying float vHoverMix;
        varying float vAirplaneMix;
        varying float vAirplaneProximity;
        #include <fog_pars_vertex>
        uniform sampler2D uMap;
        uniform float uScale;
        uniform float uBias;
        uniform float uPointSize;
        uniform float uTime;
        uniform float uJitter;
        uniform vec2 uMaskCenter;
        uniform float uMaskRadius;
        uniform float uMaskFeather;
        uniform vec2 uHoverCenter;
        uniform float uHoverRadius;
        uniform float uHoverStrength;
        uniform float uHoverSnap;
        uniform float uHoverEnabled;
        uniform vec3 uAirplanePos;
        uniform float uAirplaneHoverEnabled;
        uniform float uAirplaneHoverRadius;
        // hash-based 2D noise -> scalar in [-1,1]
        float hash(vec2 p){
          return -1.0 + 2.0 * fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }
        void main() {
          #include <uv_vertex>
          vec3 p = position;
          float h = 0.0;
          #ifdef USE_UV
          vec3 c = texture2D(uMap, vUv).rgb;
          h = (c.r + c.g + c.b) / 3.0;
          #endif
          // apply small XY jitter in object space based on vUv
          if (uJitter > 0.0) {
            float jx = hash(vUv + 0.123) * uJitter;
            float jz = hash(vUv + 4.567) * uJitter;
            p.x += jx;
            p.z += jz;
          }
          // base height
          float baseY = h * uScale + uBias;
          p.y = baseY;
          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = max(1.0, uPointSize * (300.0 / max(1.0, -mvPosition.z)));
          vec4 worldPos = modelMatrix * vec4(p, 1.0);
          float d = length(worldPos.xz - uMaskCenter);
          float edge0 = uMaskRadius;
          float edge1 = uMaskRadius + max(0.0001, uMaskFeather);
          vMaskAlpha = 1.0 - smoothstep(edge0, edge1, d);
          // mouse hover influence factor 0..1 with soft falloff
          float hd = length(worldPos.xz - uHoverCenter);
          float hEdge = uHoverRadius;
          vHoverMix = uHoverEnabled * (1.0 - smoothstep(hEdge, hEdge + 0.5, hd));
          // airplane hover - distance in XZ plane from airplane
          float airDist = length(worldPos.xz - uAirplanePos.xz);
          float airEdge = uAirplaneHoverRadius;
          vAirplaneMix = uAirplaneHoverEnabled * (1.0 - smoothstep(airEdge, airEdge + 0.8, airDist));
          // proximity factor: how close is the particle to airplane vertically (0=far, 1=close)
          // Use signed distance - particles ABOVE airplane are far (green), BELOW or at same level are close (red)
          float vertDist = uAirplanePos.y - worldPos.y; // positive when airplane is above particle
          vAirplaneProximity = 1.0 - clamp(vertDist / 0.6, 0.0, 1.0); // 0=airplane high above, 1=at or below particle
          #include <fog_vertex>
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform vec3 uHoverColor;
        uniform vec3 uAirplaneColorFar;
        uniform vec3 uAirplaneColorClose;
        varying float vMaskAlpha;
        varying float vHoverMix;
        varying float vAirplaneMix;
        varying float vAirplaneProximity;
        #include <fog_pars_fragment>
        void main() {
          vec2 pc = gl_PointCoord - 0.5;
          float r = length(pc);
          float disc = 1.0 - smoothstep(0.5, 0.55, r);
          float alpha = disc * vMaskAlpha;
          if (alpha <= 0.001) discard;
          // Start with base color
          vec3 col = uColor;
          // Apply mouse hover color
          col = mix(col, uHoverColor, vHoverMix);
          // Apply airplane hover - blend between far (orange) and close (red) based on proximity
          vec3 airplaneColor = mix(uAirplaneColorFar, uAirplaneColorClose, vAirplaneProximity);
          col = mix(col, airplaneColor, vAirplaneMix);
          gl_FragColor = vec4(col, alpha);
          #include <fog_fragment>
        }
      `
    });
    // Enable UV chunks in shader includes
    pointMaterial.defines = pointMaterial.defines || {};
    pointMaterial.defines.USE_UV = '';
    

    // (Trail system removed)

    // ========== AIRPLANE ==========
    let airplane = null;
    let airplaneGroup = null;
    const airplaneState = {
      enabled: false,
      x: 0,          // current X position (world space offset from center)
      targetX: 0,    // target X position
      y: 0,          // current Y offset (altitude adjustment)
      targetY: 0,    // target Y offset
      tilt: 0,       // current tilt (roll) angle
      pitch: 0,      // current pitch angle
      speed: 3,      // horizontal movement speed
      vertSpeed: 2,  // vertical movement speed
      maxOffset: 5.5,  // max left/right offset
      altitudeRange: 1.5, // max up/down range
      smoothing: 8,  // lerp smoothing factor
      height: -2.5,  // height offset from camera
      size: 0.4,     // scale of the airplane
      distance: 3.5, // distance ahead of camera
      // Collision state
      isColliding: false,
      collisionShake: 0,
      collisionThreshold: -0.1, // negative = only trigger when actually below terrain
    };
    
    // Store airplane materials for color change on collision
    let airplaneMaterials = [];
    const keysPressed = { left: false, right: false, up: false, down: false };

    function createAirplane() {
      // Create a retro wireframe arrow pointing forward
      const group = new THREE.Group();
      
      // Arrow outline - wireframe style like retro arcade radar
      // Arrow points forward (+Z direction after 180 flip)
      const arrowVerts = new Float32Array([
        // Arrow shape pointing forward (nose at front)
        0, 0, 0.5,        // nose (front tip)
        -0.25, 0, -0.3,   // left back corner
        0, 0, -0.15,      // center notch (back)
        
        0, 0, 0.5,        // nose (front tip)
        0, 0, -0.15,      // center notch (back)
        0.25, 0, -0.3,    // right back corner
        
        // Close the back
        -0.25, 0, -0.3,   // left back corner
        0, 0, -0.15,      // center notch
        0.25, 0, -0.3,    // right back corner
      ]);
      
      const arrowGeo = new THREE.BufferGeometry();
      arrowGeo.setAttribute('position', new THREE.BufferAttribute(arrowVerts, 3));
      
      // Wireframe material - retro arcade look
      const wireMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });
      
      const arrow = new THREE.Mesh(arrowGeo, wireMat);
      group.add(arrow);
      
      // Store materials for collision color change
      airplaneMaterials = [wireMat];
      
      // Add edge lines for cleaner wireframe look
      const edgeVerts = new Float32Array([
        // Outline of the arrow
        0, 0, 0.5,        // nose
        -0.25, 0, -0.3,   // left back
        -0.25, 0, -0.3,   // left back
        0, 0, -0.15,      // center notch
        0, 0, -0.15,      // center notch
        0.25, 0, -0.3,    // right back
        0.25, 0, -0.3,    // right back
        0, 0, 0.5,        // back to nose
      ]);
      
      const edgeGeo = new THREE.BufferGeometry();
      edgeGeo.setAttribute('position', new THREE.BufferAttribute(edgeVerts, 3));
      
      const lineMat = new THREE.LineBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 1.0,
        linewidth: 2
      });
      
      const edges = new THREE.LineSegments(edgeGeo, lineMat);
      group.add(edges);
      
      // Add line material to stored materials
      airplaneMaterials.push(lineMat);
      
      // Scale based on airplaneState.size
      group.scale.set(airplaneState.size, airplaneState.size, airplaneState.size);
      
      return group;
    }

    function initAirplane() {
      if (airplaneGroup) {
        scene.remove(airplaneGroup);
        airplaneGroup = null;
      }
      airplaneGroup = createAirplane();
      airplaneGroup.visible = airplaneState.enabled;
      scene.add(airplaneGroup);
    }

    function updateAirplane(delta) {
      if (!airplaneGroup || !airplaneState.enabled) return;
      
      // Handle horizontal input - update target position
      if (keysPressed.left) {
        airplaneState.targetX = Math.max(-airplaneState.maxOffset, airplaneState.targetX - airplaneState.speed * delta);
      }
      if (keysPressed.right) {
        airplaneState.targetX = Math.min(airplaneState.maxOffset, airplaneState.targetX + airplaneState.speed * delta);
      }
      
      // Handle vertical input - update target altitude
      if (keysPressed.up) {
        airplaneState.targetY = Math.min(airplaneState.altitudeRange, airplaneState.targetY + airplaneState.vertSpeed * delta);
      }
      if (keysPressed.down) {
        airplaneState.targetY = Math.max(-airplaneState.altitudeRange, airplaneState.targetY - airplaneState.vertSpeed * delta);
      }
      
      // Smooth horizontal movement toward target
      const dx = airplaneState.targetX - airplaneState.x;
      airplaneState.x += dx * Math.min(1, airplaneState.smoothing * delta);
      
      // Smooth vertical movement toward target
      const dy = airplaneState.targetY - airplaneState.y;
      airplaneState.y += dy * Math.min(1, airplaneState.smoothing * delta);
      
      // Calculate tilt based on movement direction (bank into turns like real airplane)
      const targetTilt = dx * 1.25; // reversed tilt, reduced by 50%
      airplaneState.tilt += (targetTilt - airplaneState.tilt) * Math.min(1, 6 * delta);
      
      // Calculate pitch based on vertical movement
      const targetPitch = -dy * 0.8; // nose up when climbing, down when diving
      airplaneState.pitch += (targetPitch - airplaneState.pitch) * Math.min(1, 6 * delta);
      
      // Position airplane relative to camera
      // Get camera's forward direction on XZ plane
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      // Get right vector
      const right = new THREE.Vector3();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      
      // Position airplane in front of and slightly below camera
      airplaneGroup.position.copy(camera.position);
      airplaneGroup.position.addScaledVector(forward, airplaneState.distance);
      airplaneGroup.position.addScaledVector(right, airplaneState.x);
      airplaneGroup.position.y = camera.position.y + airplaneState.height + airplaneState.y;
      
      // Update scale
      airplaneGroup.scale.set(airplaneState.size, airplaneState.size, airplaneState.size);
      
      // Orient airplane to face camera's forward direction with tilt and pitch
      const lookTarget = airplaneGroup.position.clone().add(forward);
      airplaneGroup.lookAt(lookTarget);
      airplaneGroup.rotation.z = airplaneState.tilt;
      airplaneGroup.rotation.x += airplaneState.pitch;
      
      const time = performance.now() * 0.001;
      
      // Collision detection - sample actual terrain height at airplane position
      const terrainHeight = sampleTerrainHeight(airplaneGroup.position.x, airplaneGroup.position.z);
      
      const wasColliding = airplaneState.isColliding;
      if (terrainHeight !== null) {
        // Compare airplane Y to actual terrain height at this position
        const clearance = airplaneGroup.position.y - terrainHeight;
        airplaneState.isColliding = clearance < airplaneState.collisionThreshold;
      } else {
        airplaneState.isColliding = false; // No heightmap yet
      }
      
      // Handle collision effects
      // Get target colors from uniforms (which are synced with params)
      const dangerColor = pointMaterial.uniforms.uAirplaneColorClose.value;
      const safeColor = pointMaterial.uniforms.uAirplaneColorFar.value;
      
      if (airplaneState.isColliding) {
        // Increase shake intensity
        airplaneState.collisionShake = Math.min(airplaneState.collisionShake + delta * 15, 1.0);
        
        // Turn airplane to danger color
        for (const mat of airplaneMaterials) {
          mat.color.copy(dangerColor);
        }
        
        // Apply shake
        const shakeIntensity = airplaneState.collisionShake * 0.08;
        airplaneGroup.position.x += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.position.y += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.position.z += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.rotation.z += (Math.random() - 0.5) * shakeIntensity * 0.5;
      } else {
        // Decay shake when not colliding
        airplaneState.collisionShake = Math.max(airplaneState.collisionShake - delta * 5, 0);
        
        // Transition to safe color smoothly
        for (const mat of airplaneMaterials) {
          const currentColor = mat.color;
          currentColor.r += (safeColor.r - currentColor.r) * delta * 5;
          currentColor.g += (safeColor.g - currentColor.g) * delta * 5;
          currentColor.b += (safeColor.b - currentColor.b) * delta * 5;
        }
        
        // Add subtle bobbing motion only when not colliding
        airplaneGroup.position.y += Math.sin(time * 2) * 0.02;
      }
    }

    // Keyboard controls for airplane
    window.addEventListener('keydown', (e) => {
      if (!airplaneState.enabled) return;
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        keysPressed.left = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        keysPressed.right = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysPressed.up = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysPressed.down = true;
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        keysPressed.left = false;
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        keysPressed.right = false;
      }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysPressed.up = false;
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysPressed.down = false;
      }
    });

    // Initialize airplane
    initAirplane();

    // ========== GOOGLE 3D TILES / POINT CLOUD ==========
    let tilesRenderer = null;
    let tilesGroup = null;
    let pointCloudMode = 'heightmap'; // 'heightmap' | 'google3d' | 'ply'
    let extractedPointCloud = null;

    const tiles3DState = {
      enabled: false,
      apiKey: '',
      latitude: 48.8584,  // Paris - Eiffel Tower
      longitude: 2.2945,
      altitude: 300,
      pointDensity: 1.0,  // 1.0 = use all vertices, 0.1 = use 10%
      sceneScale: 0.001,  // Scale factor from meters to scene units
      showMesh: false,    // Show original mesh alongside point cloud
    };

    // Preset locations for quick testing
    const presetLocations = {
      'Paris - Tour Eiffel': { lat: 48.8584, lon: 2.2945, alt: 300 },
      'New York - Manhattan': { lat: 40.7484, lon: -73.9857, alt: 400 },
      'San Francisco': { lat: 37.7749, lon: -122.4194, alt: 300 },
      'Tokyo - Shibuya': { lat: 35.6595, lon: 139.7004, alt: 250 },
      'London - Big Ben': { lat: 51.5007, lon: -0.1246, alt: 200 },
      'Sydney Opera House': { lat: -33.8568, lon: 151.2153, alt: 200 },
      'Dubai - Burj Khalifa': { lat: 25.1972, lon: 55.2744, alt: 500 },
    };

    // WGS84 ellipsoid parameters
    const WGS84_A = 6378137.0;  // semi-major axis
    const WGS84_B = 6356752.314245;  // semi-minor axis

    // Convert lat/lon/alt to ECEF (Earth-Centered, Earth-Fixed)
    function latLonToECEF(lat, lon, alt) {
      const latRad = lat * Math.PI / 180;
      const lonRad = lon * Math.PI / 180;
      const e2 = 1 - (WGS84_B * WGS84_B) / (WGS84_A * WGS84_A);
      const N = WGS84_A / Math.sqrt(1 - e2 * Math.sin(latRad) * Math.sin(latRad));
      const x = (N + alt) * Math.cos(latRad) * Math.cos(lonRad);
      const y = (N + alt) * Math.cos(latRad) * Math.sin(lonRad);
      const z = (N * (1 - e2) + alt) * Math.sin(latRad);
      return new THREE.Vector3(x, y, z);
    }

    // Get the ENU (East-North-Up) rotation matrix for a lat/lon position
    function getENURotation(lat, lon) {
      const latRad = lat * Math.PI / 180;
      const lonRad = lon * Math.PI / 180;
      // Create rotation matrix for ENU coordinate system
      const m = new THREE.Matrix4();
      m.set(
        -Math.sin(lonRad), -Math.sin(latRad) * Math.cos(lonRad), Math.cos(latRad) * Math.cos(lonRad), 0,
        Math.cos(lonRad), -Math.sin(latRad) * Math.sin(lonRad), Math.cos(latRad) * Math.sin(lonRad), 0,
        0, Math.cos(latRad), Math.sin(latRad), 0,
        0, 0, 0, 1
      );
      return m;
    }

    async function initGoogleTiles() {
      if (!tiles3DState.apiKey) {
        console.warn('Google 3D Tiles: API key required');
        return;
      }

      // Clean up existing tiles
      if (tilesRenderer) {
        tilesRenderer.dispose();
        tilesRenderer = null;
      }
      if (tilesGroup) {
        scene.remove(tilesGroup);
        tilesGroup = null;
      }

      try {
        tilesGroup = new THREE.Group();
        scene.add(tilesGroup);

        tilesRenderer = new TilesRenderer();

        // Register plugins
        tilesRenderer.registerPlugin(new GoogleCloudAuthPlugin({
          apiToken: tiles3DState.apiKey,
          autoRefreshToken: true
        }));
        tilesRenderer.registerPlugin(new GLTFExtensionsPlugin());
        tilesRenderer.registerPlugin(new TileCompressionPlugin());
        tilesRenderer.registerPlugin(new UpdateOnChangePlugin());

        // Configure renderer
        tilesRenderer.setCamera(camera);
        tilesRenderer.setResolutionFromRenderer(camera, renderer);

        // Add to scene group
        tilesGroup.add(tilesRenderer.group);

        // Position camera based on lat/lon
        updateTilesPosition();

        console.log('Google 3D Tiles initialized');
        tiles3DState.enabled = true;

      } catch (err) {
        console.error('Failed to initialize Google 3D Tiles:', err);
        tiles3DState.enabled = false;
      }
    }

    function updateTilesPosition() {
      if (!tilesRenderer || !tilesGroup) return;

      const ecefPos = latLonToECEF(tiles3DState.latitude, tiles3DState.longitude, tiles3DState.altitude);
      const enuRotation = getENURotation(tiles3DState.latitude, tiles3DState.longitude);

      // Scale and position the tiles group
      const scale = tiles3DState.sceneScale;
      tilesGroup.scale.set(scale, scale, scale);

      // Calculate the offset so the target location is at origin
      tilesGroup.position.set(
        -ecefPos.x * scale,
        -ecefPos.z * scale,  // Swap Y/Z for Three.js coordinate system
        -ecefPos.y * scale
      );

      // Apply ENU rotation so "up" is correct
      tilesGroup.setRotationFromMatrix(enuRotation);
    }

    // Extract point cloud from loaded 3D Tiles meshes
    function extractPointCloudFromTiles() {
      if (!tilesRenderer) return null;

      const positions = [];
      const colors = [];
      const density = tiles3DState.pointDensity;

      // Traverse all loaded tiles and extract vertices
      tilesRenderer.group.traverse((child) => {
        if (child.isMesh && child.geometry) {
          const geo = child.geometry;
          const posAttr = geo.getAttribute('position');
          const colorAttr = geo.getAttribute('color');
          const normalAttr = geo.getAttribute('normal');

          if (!posAttr) return;

          // Get world matrix for this mesh
          const worldMatrix = child.matrixWorld;
          const tempVec = new THREE.Vector3();
          const tempColor = new THREE.Color();

          // Sample vertices based on density
          const step = Math.max(1, Math.floor(1 / density));
          for (let i = 0; i < posAttr.count; i += step) {
            // Get position in world space
            tempVec.fromBufferAttribute(posAttr, i);
            tempVec.applyMatrix4(worldMatrix);

            // Apply scene scale
            tempVec.multiplyScalar(tiles3DState.sceneScale);

            positions.push(tempVec.x, tempVec.y, tempVec.z);

            // Get color if available, otherwise use white
            if (colorAttr) {
              tempColor.fromBufferAttribute(colorAttr, i);
              colors.push(tempColor.r, tempColor.g, tempColor.b);
            } else {
              colors.push(1, 1, 1);
            }
          }
        }
      });

      if (positions.length === 0) return null;

      // Create point cloud geometry
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeBoundingSphere();

      return geometry;
    }

    // Create point cloud material for extracted tiles
    const tilesPointMaterial = new THREE.PointsMaterial({
      size: 0.02,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      sizeAttenuation: true,
    });

    function updateExtractedPointCloud() {
      if (extractedPointCloud) {
        scene.remove(extractedPointCloud);
        if (extractedPointCloud.geometry) extractedPointCloud.geometry.dispose();
        extractedPointCloud = null;
      }

      if (!tiles3DState.enabled || !tilesRenderer) return;

      const geometry = extractPointCloudFromTiles();
      if (geometry) {
        extractedPointCloud = new THREE.Points(geometry, tilesPointMaterial);
        extractedPointCloud.frustumCulled = false;
        scene.add(extractedPointCloud);
        console.log('Point cloud extracted:', geometry.getAttribute('position').count, 'points');
      }
    }

    function disposeTiles() {
      if (extractedPointCloud) {
        scene.remove(extractedPointCloud);
        if (extractedPointCloud.geometry) extractedPointCloud.geometry.dispose();
        extractedPointCloud = null;
      }
      if (tilesRenderer) {
        tilesRenderer.dispose();
        tilesRenderer = null;
      }
      if (tilesGroup) {
        scene.remove(tilesGroup);
        tilesGroup = null;
      }
      tiles3DState.enabled = false;
    }

    // ========== PLY POINT CLOUD LOADER ==========
    async function loadPLYFile(file) {
      const text = await file.text();
      const lines = text.split('\n');

      let headerEnd = 0;
      let vertexCount = 0;
      let hasColor = false;

      // Parse header
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === 'end_header') {
          headerEnd = i + 1;
          break;
        }
        if (line.startsWith('element vertex')) {
          vertexCount = parseInt(line.split(' ')[2]);
        }
        if (line.startsWith('property') && (line.includes('red') || line.includes('r '))) {
          hasColor = true;
        }
      }

      const positions = [];
      const colors = [];

      // Parse vertices
      for (let i = 0; i < vertexCount && (headerEnd + i) < lines.length; i++) {
        const line = lines[headerEnd + i].trim();
        if (!line) continue;

        const parts = line.split(/\s+/);
        if (parts.length >= 3) {
          positions.push(parseFloat(parts[0]), parseFloat(parts[1]), parseFloat(parts[2]));

          if (hasColor && parts.length >= 6) {
            colors.push(parseFloat(parts[3]) / 255, parseFloat(parts[4]) / 255, parseFloat(parts[5]) / 255);
          } else {
            colors.push(0.8, 0.8, 0.8);
          }
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeBoundingSphere();
      geometry.computeBoundingBox();

      // Center and scale the point cloud
      const center = new THREE.Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);

      // Scale to fit in scene
      const size = geometry.boundingBox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 10 / maxDim;  // Fit in ~10 unit box
      geometry.scale(scale, scale, scale);

      return geometry;
    }

    // Tiling with Points
    let tilesPoints = [];
    const state = { tileSize: initialSize, tilesX: 3, tilesZ: 3, scrollSpeed: 3 };
    const scrollOffset = new THREE.Vector2(0, 0);

    function buildBaseGeometry() {
      const g = new THREE.PlaneGeometry(state.tileSize, state.tileSize, segments, segments);
      g.rotateX(-Math.PI / 2);
      return g;
    }

    function positiveModulo(v, m) { return ((v % m) + m) % m; }

    function updateTileMatrices() {
      if (!tilesPoints || tilesPoints.length === 0) return;
      let idx = 0;
      const offsetX = (state.tilesX - 1) * state.tileSize * 0.5;
      const offsetZ = (state.tilesZ - 1) * state.tileSize * 0.5;
      const modX = positiveModulo(scrollOffset.x, state.tileSize);
      const modZ = positiveModulo(scrollOffset.y, state.tileSize);
      for (let z = 0; z < state.tilesZ; z++) {
        for (let x = 0; x < state.tilesX; x++) {
          const px = (x * state.tileSize) - offsetX - modX;
          const pz = (z * state.tileSize) - offsetZ - modZ;
          const pts = tilesPoints[idx++];
          if (pts) pts.position.set(px, 0, pz);
        }
      }
    }

    function rebuildTiling() {
      if (tilesPoints && tilesPoints.length) {
        for (const p of tilesPoints) {
          scene.remove(p);
          if (p.geometry) p.geometry.dispose();
        }
      }
      tilesPoints = [];
      const geometry = buildBaseGeometry();
      geometry.deleteAttribute('normal');
      geometry.deleteAttribute('tangent');
      // Ensure each vertex becomes a point; PlaneGeometry already has indexed triangles.
      // Convert to non-indexed so every vertex is unique for gl.POINTS
      const nonIndexed = geometry.toNonIndexed();
      nonIndexed.computeBoundingSphere();
      for (let z = 0; z < state.tilesZ; z++) {
        for (let x = 0; x < state.tilesX; x++) {
          const pts = new THREE.Points(nonIndexed, pointMaterial);
          pts.frustumCulled = false;
          tilesPoints.push(pts);
          scene.add(pts);
        }
      }
      updateTileMatrices();
    }

    rebuildTiling();

    // (Car and follower removed)

    // (CPU height sampling removed)

    // (Cursor/mouse following removed)

    // UI elements
    const fileInput = document.getElementById('heightmapFile');

    // Tweakpane setup
    const pane = new Pane({ title: 'Particle Landscape' });
    
    // Parameters object
    const params = {
      // Heightmap
      terrainColor: '#8a8f9a',
      scale: 1.4,
      tileSize: 11,
      tilesX: 1,
      tilesZ: 3,
      // Particles
      pointSize: 0.01,
      jitter: 0.02,
      hoverRadius: 1.6,
      hoverStrength: 0.8,
      hoverSnap: 2.0,
      hoverColor: '#ffcc55',
      cols: 416,
      rows: 416,
      // Mask
      maskRadius: 3.0,
      maskFeather: 0.8,
      // Animation
      scrollSpeed: 0.6,
      animateScroll: true,
      // Camera
      camYaw: 0,
      camPitch: -41,
      camFov: 90,
      camHeight: 3.0,
      camZ: 5.4,
      // Fog
      fogEnabled: true,
      fogColor: '#0e0f13',
      fogNear: 12,
      fogFar: 1,
      // Airplane
      airplaneEnabled: false,
      airplaneSpeed: 3,
      airplaneMaxOffset: 5.5,
      airplaneVertSpeed: 2,
      airplaneAltitudeRange: 1.5,
      airplaneHeight: -2.5,
      airplaneSize: 0.4,
      airplaneDistance: 3.5,
      // Hover highlights
      mouseHoverEnabled: true,
      airplaneHoverEnabled: true,
      airplaneHoverRadius: 2.0,
      airplaneColorSafe: '#00ffaa',   // cyan-green when high/safe
      airplaneColorDanger: '#ff0000', // red when low/danger
    };

    // Helper functions
    const degToRad = (d) => d * Math.PI / 180;
    const clampPitchDeg = (p) => Math.max(-89, Math.min(89, p));
    function applyYawPitchDeg(yawDeg, pitchDeg) {
      const yaw = degToRad(yawDeg);
      const pitch = degToRad(clampPitchDeg(pitchDeg));
      const e = new THREE.Euler(pitch, yaw, 0, 'YXZ');
      camera.quaternion.setFromEuler(e);
    }

    function clampPowerOfTwo(n) {
      return Math.max(2, Math.min(2048, Math.floor(n)));
    }

    function applyFogFromParams() {
      if (params.fogEnabled) {
        scene.fog = new THREE.Fog(
          params.fogColor, 
          Math.min(params.fogNear, params.fogFar - 0.001), 
          Math.max(params.fogNear + 0.001, params.fogFar)
        );
        scene.background = new THREE.Color(params.fogColor);
      } else {
        scene.fog = null;
      }
    }

    // Point Cloud Source folder
    const sourceFolder = pane.addFolder({ title: 'Point Cloud Source', expanded: true });
    const sourceParams = {
      mode: 'heightmap',
      presetLocation: 'Paris - Tour Eiffel',
    };

    sourceFolder.addBinding(sourceParams, 'mode', {
      label: 'Source',
      options: {
        'Heightmap': 'heightmap',
        'Google 3D Tiles': 'google3d',
        'PLY File': 'ply',
      }
    }).on('change', (ev) => {
      pointCloudMode = ev.value;
      updateSourceVisibility();
    });

    // Google 3D Tiles subfolder
    const google3DFolder = sourceFolder.addFolder({ title: 'Google 3D Tiles', expanded: true });

    google3DFolder.addBinding(tiles3DState, 'apiKey', { label: 'API Key' });

    google3DFolder.addBinding(sourceParams, 'presetLocation', {
      label: 'Preset',
      options: Object.fromEntries(Object.keys(presetLocations).map(k => [k, k]))
    }).on('change', (ev) => {
      const loc = presetLocations[ev.value];
      if (loc) {
        tiles3DState.latitude = loc.lat;
        tiles3DState.longitude = loc.lon;
        tiles3DState.altitude = loc.alt;
        pane.refresh();
        if (tiles3DState.enabled) updateTilesPosition();
      }
    });

    google3DFolder.addBinding(tiles3DState, 'latitude', { label: 'Latitude', min: -90, max: 90, step: 0.0001 }).on('change', () => {
      if (tiles3DState.enabled) updateTilesPosition();
    });
    google3DFolder.addBinding(tiles3DState, 'longitude', { label: 'Longitude', min: -180, max: 180, step: 0.0001 }).on('change', () => {
      if (tiles3DState.enabled) updateTilesPosition();
    });
    google3DFolder.addBinding(tiles3DState, 'altitude', { label: 'Altitude (m)', min: 50, max: 2000, step: 10 }).on('change', () => {
      if (tiles3DState.enabled) updateTilesPosition();
    });

    google3DFolder.addBlade({ view: 'separator' });

    google3DFolder.addBinding(tiles3DState, 'pointDensity', { label: 'Point Density', min: 0.01, max: 1, step: 0.01 });
    google3DFolder.addBinding(tiles3DState, 'sceneScale', { label: 'Scene Scale', min: 0.0001, max: 0.01, step: 0.0001 });
    google3DFolder.addBinding(tiles3DState, 'showMesh', { label: 'Show Mesh' }).on('change', (ev) => {
      if (tilesGroup) tilesGroup.visible = ev.value;
    });

    google3DFolder.addBlade({ view: 'separator' });

    google3DFolder.addButton({ title: 'Load Google 3D Tiles' }).on('click', async () => {
      if (!tiles3DState.apiKey) {
        alert('Please enter a Google Maps API key first.\n\nGet one at: https://console.cloud.google.com/apis/library/tile.googleapis.com');
        return;
      }
      // Hide heightmap tiles
      for (const p of tilesPoints) p.visible = false;
      await initGoogleTiles();
    });

    google3DFolder.addButton({ title: 'Extract Point Cloud' }).on('click', () => {
      updateExtractedPointCloud();
    });

    google3DFolder.addButton({ title: 'Disable & Clear' }).on('click', () => {
      disposeTiles();
      // Show heightmap tiles again
      for (const p of tilesPoints) p.visible = true;
    });

    // PLY file loader
    const plyFolder = sourceFolder.addFolder({ title: 'PLY File', expanded: false });
    const plyFileInput = document.createElement('input');
    plyFileInput.type = 'file';
    plyFileInput.accept = '.ply';
    plyFileInput.style.display = 'none';
    document.body.appendChild(plyFileInput);

    plyFolder.addButton({ title: 'Load PLY File...' }).on('click', () => {
      plyFileInput.click();
    });

    plyFileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      try {
        const geometry = await loadPLYFile(file);

        // Clear existing point cloud
        if (extractedPointCloud) {
          scene.remove(extractedPointCloud);
          if (extractedPointCloud.geometry) extractedPointCloud.geometry.dispose();
        }

        // Hide heightmap tiles
        for (const p of tilesPoints) p.visible = false;

        // Create point cloud from PLY
        extractedPointCloud = new THREE.Points(geometry, tilesPointMaterial);
        extractedPointCloud.frustumCulled = false;
        scene.add(extractedPointCloud);

        console.log('PLY loaded:', geometry.getAttribute('position').count, 'points');
      } catch (err) {
        console.error('Failed to load PLY file:', err);
        alert('Failed to load PLY file: ' + err.message);
      }
    });

    function updateSourceVisibility() {
      google3DFolder.hidden = pointCloudMode !== 'google3d';
      plyFolder.hidden = pointCloudMode !== 'ply';

      if (pointCloudMode === 'heightmap') {
        // Show heightmap tiles, hide extracted point cloud
        for (const p of tilesPoints) p.visible = true;
        if (extractedPointCloud) extractedPointCloud.visible = false;
        disposeTiles();
      } else if (pointCloudMode === 'google3d') {
        // Will show when loaded
      } else if (pointCloudMode === 'ply') {
        // PLY mode - hide heightmap
        for (const p of tilesPoints) p.visible = false;
        if (extractedPointCloud) extractedPointCloud.visible = true;
      }
    }

    // Initialize visibility
    updateSourceVisibility();

    sourceFolder.addBlade({ view: 'separator' });

    // Heightmap folder
    const heightmapFolder = pane.addFolder({ title: 'Heightmap', expanded: true });
    heightmapFolder.addButton({ title: 'Load Heightmap...' }).on('click', () => {
      fileInput.click();
    });
    heightmapFolder.addBinding(params, 'terrainColor', { view: 'color' }).on('change', (ev) => {
      pointMaterial.uniforms.uColor.value.set(ev.value);
    });
    heightmapFolder.addBinding(params, 'scale', { min: 0, max: 8, step: 0.1 }).on('change', (ev) => {
      pointMaterial.uniforms.uScale.value = ev.value;
      pointMaterial.uniforms.uBias.value = -ev.value * 0.5;
    });
    heightmapFolder.addBinding(params, 'tileSize', { min: 2, max: 50, step: 1 }).on('change', (ev) => {
      state.tileSize = Math.max(1, ev.value);
      rebuildTiling();
    });
    heightmapFolder.addBinding(params, 'tilesX', { min: 1, max: 20, step: 1 }).on('change', (ev) => {
      state.tilesX = Math.max(1, Math.min(20, ev.value));
      rebuildTiling();
    });
    heightmapFolder.addBinding(params, 'tilesZ', { min: 1, max: 20, step: 1 }).on('change', (ev) => {
      state.tilesZ = Math.max(1, Math.min(20, ev.value));
      rebuildTiling();
    });

    // Particles folder
    const particlesFolder = pane.addFolder({ title: 'Particles', expanded: true });
    particlesFolder.addBinding(params, 'pointSize', { min: 0, max: 0.5, step: 0.01, label: 'Point Size' }).on('change', (ev) => {
      pointMaterial.uniforms.uPointSize.value = ev.value;
    });
    particlesFolder.addBinding(params, 'jitter', { min: 0.0, max: 0.2, step: 0.001 }).on('change', (ev) => {
      pointMaterial.uniforms.uJitter.value = ev.value;
    });
    particlesFolder.addBlade({ view: 'separator' });
    particlesFolder.addBinding(params, 'hoverRadius', { min: 0.1, max: 10, step: 0.1, label: 'Hover Radius' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverRadius.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverStrength', { min: 0, max: 10, step: 0.1, label: 'Hover Strength' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverStrength.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverSnap', { min: 0.1, max: 10, step: 0.1, label: 'Hover Snap' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverSnap.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverColor', { view: 'color', label: 'Hover Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverColor.value.set(ev.value);
    });
    particlesFolder.addBinding(params, 'mouseHoverEnabled', { label: 'Mouse Hover' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverEnabled.value = ev.value ? 1.0 : 0.0;
    });
    particlesFolder.addBlade({ view: 'separator' });
    particlesFolder.addBinding(params, 'cols', { min: 8, max: 1024, step: 8 }).on('change', (ev) => {
      params.cols = clampPowerOfTwo(ev.value);
      segments = Math.max(2, Math.max(params.cols, params.rows));
      rebuildTiling();
    });
    particlesFolder.addBinding(params, 'rows', { min: 8, max: 1024, step: 8 }).on('change', (ev) => {
      params.rows = clampPowerOfTwo(ev.value);
      segments = Math.max(2, Math.max(params.cols, params.rows));
      rebuildTiling();
    });

    // Mask folder
    const maskFolder = pane.addFolder({ title: 'Mask', expanded: true });
    maskFolder.addBinding(params, 'maskRadius', { min: 0.1, max: 20, step: 0.1, label: 'Mask Radius' }).on('change', (ev) => {
      pointMaterial.uniforms.uMaskRadius.value = ev.value;
    });
    maskFolder.addBinding(params, 'maskFeather', { min: 0.0, max: 5, step: 0.1, label: 'Mask Feather' }).on('change', (ev) => {
      pointMaterial.uniforms.uMaskFeather.value = ev.value;
    });

    // Animation folder
    const animationFolder = pane.addFolder({ title: 'Animation', expanded: true });
    animationFolder.addBinding(params, 'scrollSpeed', { min: -20, max: 20, step: 0.1, label: 'Scroll Speed' }).on('change', (ev) => {
      state.scrollSpeed = ev.value;
    });
    animationFolder.addBinding(params, 'animateScroll', { label: 'Animate' });

    // Airplane folder
    const airplaneFolder = pane.addFolder({ title: 'Airplane', expanded: true });
    airplaneFolder.addBinding(params, 'airplaneEnabled', { label: 'Enable Airplane' }).on('change', (ev) => {
      airplaneState.enabled = ev.value;
      if (airplaneGroup) airplaneGroup.visible = ev.value;
      // Reset position when toggled on
      if (ev.value) {
        airplaneState.x = 0;
        airplaneState.targetX = 0;
        airplaneState.y = 0;
        airplaneState.targetY = 0;
        airplaneState.tilt = 0;
        airplaneState.pitch = 0;
      }
    });
    airplaneFolder.addBinding(params, 'airplaneSpeed', { min: 1, max: 20, step: 0.5, label: 'Move Speed' }).on('change', (ev) => {
      airplaneState.speed = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneMaxOffset', { min: 1, max: 15, step: 0.5, label: 'Max Offset' }).on('change', (ev) => {
      airplaneState.maxOffset = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneVertSpeed', { min: 0.5, max: 5, step: 0.1, label: 'Vert Speed' }).on('change', (ev) => {
      airplaneState.vertSpeed = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneAltitudeRange', { min: 0.5, max: 5, step: 0.1, label: 'Alt Range' }).on('change', (ev) => {
      airplaneState.altitudeRange = ev.value;
    });
    airplaneFolder.addBlade({ view: 'separator' });
    airplaneFolder.addBinding(params, 'airplaneHeight', { min: -5, max: 1, step: 0.1, label: 'Height' }).on('change', (ev) => {
      airplaneState.height = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneSize', { min: 0.2, max: 3, step: 0.1, label: 'Size' }).on('change', (ev) => {
      airplaneState.size = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneDistance', { min: 1, max: 10, step: 0.1, label: 'Distance' }).on('change', (ev) => {
      airplaneState.distance = ev.value;
    });
    airplaneFolder.addBlade({ view: 'separator' });
    airplaneFolder.addBinding(params, 'airplaneHoverEnabled', { label: 'Ground Highlight' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneHoverEnabled.value = ev.value ? 1.0 : 0.0;
    });
    airplaneFolder.addBinding(params, 'airplaneHoverRadius', { min: 0.5, max: 5, step: 0.1, label: 'Highlight Size' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneHoverRadius.value = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneColorSafe', { view: 'color', label: 'Safe Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneColorFar.value.set(ev.value);
    });
    airplaneFolder.addBinding(params, 'airplaneColorDanger', { view: 'color', label: 'Danger Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneColorClose.value.set(ev.value);
    });
    airplaneFolder.addBlade({ view: 'separator' });
    const airplaneHint = airplaneFolder.addBlade({
      view: 'text',
      label: '',
      parse: (v) => String(v),
      value: '↑↓←→ or WASD to fly',
    });
    airplaneHint.disabled = true;

    // Camera folder
    const cameraFolder = pane.addFolder({ title: 'Camera', expanded: true });
    cameraFolder.addBinding(params, 'camYaw', { min: -180, max: 180, step: 1, label: 'Yaw' }).on('change', (ev) => {
      applyYawPitchDeg(ev.value, params.camPitch);
    });
    cameraFolder.addBinding(params, 'camPitch', { min: -89, max: 89, step: 1, label: 'Pitch' }).on('change', (ev) => {
      applyYawPitchDeg(params.camYaw, ev.value);
    });
    cameraFolder.addBinding(params, 'camFov', { min: 20, max: 100, step: 1, label: 'FOV' }).on('change', (ev) => {
      camera.fov = ev.value;
      camera.updateProjectionMatrix();
    });
    cameraFolder.addBinding(params, 'camHeight', { min: 0, max: 100, step: 0.1, label: 'Height' }).on('change', (ev) => {
      camera.position.y = ev.value;
    });
    cameraFolder.addBinding(params, 'camZ', { min: -200, max: 200, step: 0.1, label: 'Camera Z' }).on('change', (ev) => {
      camera.position.z = ev.value;
    });
    cameraFolder.addBlade({ view: 'separator' });
    cameraFolder.addBinding(params, 'fogEnabled', { label: 'Fog Enabled' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogColor', { view: 'color', label: 'Fog Color' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogNear', { min: 0, max: 500, step: 1, label: 'Fog Near' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogFar', { min: 1, max: 1000, step: 1, label: 'Fog Far' }).on('change', applyFogFromParams);
    cameraFolder.addBlade({ view: 'separator' });
    cameraFolder.addButton({ title: 'Reset Camera' }).on('click', () => {
      camera.position.copy(defaultCamPos);
      camera.quaternion.copy(defaultCamQuat);
      const e = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      params.camYaw = Math.round(THREE.MathUtils.radToDeg(e.y));
      params.camPitch = Math.round(THREE.MathUtils.radToDeg(e.x));
      params.camFov = Math.round(camera.fov);
      params.camHeight = camera.position.y;
      params.camZ = camera.position.z;
      pane.refresh();
      scrollOffset.set(0, 0);
      updateTileMatrices();
    });

    // ---- URL parameter configuration ----
    // Allows setting values via query params and optionally hiding the UI
    (function applyUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);

      function setParam(key, paramName) {
        if (urlParams.has(paramName)) {
          const value = urlParams.get(paramName);
          if (typeof params[key] === 'boolean') {
            params[key] = value === '1' || value === 'true' || value === 'on';
        } else {
            params[key] = Number(value) || value;
          }
        }
      }

      // hide UI if ui=0
      if (urlParams.get('ui') === '0') {
        pane.hidden = true;
      }

      // common controls
      setParam('scale', 'scale');
      setParam('tileSize', 'tileSize');
      setParam('tilesX', 'tilesX');
      setParam('tilesZ', 'tilesZ');
      setParam('pointSize', 'psize');
      setParam('maskRadius', 'mask');
      setParam('maskFeather', 'feather');
      setParam('jitter', 'jitter');
      setParam('hoverRadius', 'hR');
      setParam('hoverStrength', 'hS');
      setParam('hoverSnap', 'hSnap');
      setParam('camYaw', 'yaw');
      setParam('camPitch', 'pitch');
      setParam('camFov', 'fov');
      setParam('camHeight', 'height');
      setParam('camZ', 'z');
      setParam('scrollSpeed', 'scroll');
      setParam('animateScroll', 'animate');
      setParam('cols', 'cols');
      setParam('rows', 'rows');
      setParam('fogEnabled', 'fog');
      setParam('fogNear', 'near');
      setParam('fogFar', 'far');
      // colors as hex
      if (urlParams.has('terrain')) {
        params.terrainColor = urlParams.get('terrain');
      }
      if (urlParams.has('fogColor')) {
        params.fogColor = urlParams.get('fogColor');
      }

      // Refresh pane to show URL param values
      pane.refresh();
    })();

    // Initialize camera and scene from param defaults
    (function initFromDefaults() {
      // Apply yaw/pitch
      applyYawPitchDeg(params.camYaw, params.camPitch);
      // Apply FOV
      camera.fov = params.camFov;
      camera.updateProjectionMatrix();
      // Apply height & camera Z
      camera.position.y = params.camHeight;
      camera.position.z = params.camZ;
      // Apply scroll speed
      state.scrollSpeed = params.scrollSpeed;
      // Grid visibility
      grid.visible = false;
      // Scale
      pointMaterial.uniforms.uScale.value = params.scale;
      pointMaterial.uniforms.uBias.value = -params.scale * 0.5;
      // Point color default
      pointMaterial.uniforms.uColor.value.set(params.terrainColor);
      // Jitter default
      pointMaterial.uniforms.uJitter.value = params.jitter;
      // Point defaults
      pointMaterial.uniforms.uPointSize.value = params.pointSize;
      pointMaterial.uniforms.uMaskRadius.value = params.maskRadius;
      pointMaterial.uniforms.uMaskFeather.value = params.maskFeather;
      // Hover defaults
      pointMaterial.uniforms.uHoverRadius.value = params.hoverRadius;
      pointMaterial.uniforms.uHoverStrength.value = params.hoverStrength;
      pointMaterial.uniforms.uHoverSnap.value = params.hoverSnap;
      pointMaterial.uniforms.uHoverColor.value.set(params.hoverColor);
      pointMaterial.uniforms.uHoverEnabled.value = params.mouseHoverEnabled ? 1.0 : 0.0;
      // Airplane hover defaults
      pointMaterial.uniforms.uAirplaneHoverEnabled.value = params.airplaneHoverEnabled ? 1.0 : 0.0;
      pointMaterial.uniforms.uAirplaneHoverRadius.value = params.airplaneHoverRadius;
      
      // Record defaults for Reset
      defaultCamPos = new THREE.Vector3().copy(camera.position);
      defaultCamQuat = new THREE.Quaternion().copy(camera.quaternion);
      // Initialize fog state
      applyFogFromParams();
      // Compile shader after defines updates
      pointMaterial.needsUpdate = true;
      // Load default heightmap texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        DEFAULT_HEIGHTMAP_URL,
        (tex) => {
          applyHeightmapTexture(tex).catch((err) => console.error('Failed to apply default heightmap', err));
        },
        undefined,
        (err) => {
          console.error('Failed to load default heightmap', err);
        }
      );
    })();

    // Static camera: no keyboard/mouse movement

    async function createTextureFromFile(file) {
      try {
        const bitmap = await createImageBitmap(file);
        const texture = new THREE.Texture(bitmap);
        texture.needsUpdate = true;
        return texture;
      } catch (err) {
        const dataUrl = await new Promise((resolve, reject) => {
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = reject;
          fr.readAsDataURL(file);
        });
        const img = await new Promise((resolve, reject) => {
          const i = new Image();
          i.decoding = 'async';
          i.onload = () => resolve(i);
          i.onerror = (e) => reject(e);
          i.src = dataUrl;
        });
        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        return texture;
      }
    }

    let currentHeightmapTexture = null;
    let heightmapCanvas = null;
    let heightmapCtx = null;
    let heightmapWidth = 0;
    let heightmapHeight = 0;

    // Sample terrain height at a world XZ position
    function sampleTerrainHeight(worldX, worldZ) {
      if (!heightmapCtx || !heightmapWidth || !heightmapHeight) {
        return null; // No heightmap loaded yet
      }
      
      const tileSize = state.tileSize;
      
      // Account for scroll offset - the terrain moves, so we need to sample
      // relative to the scrolling position
      const relX = worldX + scrollOffset.x;
      const relZ = worldZ + scrollOffset.y;
      
      // Convert to UV coordinates within [0,1] - the texture repeats per tile
      // Add 0.5 to center the sampling (geometry goes from -tileSize/2 to +tileSize/2)
      let u = (((relX / tileSize) + 0.5) % 1 + 1) % 1;
      let v = (((relZ / tileSize) + 0.5) % 1 + 1) % 1;
      // Flip V because PlaneGeometry rotation may invert it
      v = 1.0 - v;
      
      // Convert UV to pixel coordinates
      const px = Math.floor(u * heightmapWidth);
      const py = Math.floor(v * heightmapHeight);
      
      // Clamp to valid range
      const clampedPx = Math.max(0, Math.min(heightmapWidth - 1, px));
      const clampedPy = Math.max(0, Math.min(heightmapHeight - 1, py));
      
      // Sample the pixel
      const pixelData = heightmapCtx.getImageData(clampedPx, clampedPy, 1, 1).data;
      
      // Calculate height using same formula as shader: (r+g+b)/3 * scale + bias
      const r = pixelData[0] / 255;
      const g = pixelData[1] / 255;
      const b = pixelData[2] / 255;
      const h = (r + g + b) / 3;
      
      const scale = pointMaterial.uniforms.uScale.value;
      const bias = pointMaterial.uniforms.uBias.value;
      
      return h * scale + bias;
    }

    async function applyHeightmapTexture(texture) {
      if (currentHeightmapTexture) {
        currentHeightmapTexture.dispose();
      }
      currentHeightmapTexture = texture;
      texture.colorSpace = THREE.NoColorSpace; // treat as data
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      // NPOT safety: use clamp + no mipmaps; POT can repeat+mips
      const img = texture.image;
      const isPOT = img && ( (img.width & (img.width - 1)) === 0 ) && ( (img.height & (img.height - 1)) === 0 );
      if (isPOT) {
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.generateMipmaps = true;
        texture.minFilter = THREE.LinearMipmapLinearFilter;
      } else {
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
      }
      texture.magFilter = THREE.LinearFilter;
      texture.needsUpdate = true;

      pointMaterial.uniforms.uMap.value = texture;
      pointMaterial.uniforms.uBias.value = -pointMaterial.uniforms.uScale.value * 0.5;
      pointMaterial.needsUpdate = true;
      rebuildTiling();
      
      // Create canvas for CPU-side heightmap sampling
      const texImg = texture.image;
      if (texImg) {
        heightmapWidth = texImg.width || texImg.naturalWidth || 512;
        heightmapHeight = texImg.height || texImg.naturalHeight || 512;
        heightmapCanvas = document.createElement('canvas');
        heightmapCanvas.width = heightmapWidth;
        heightmapCanvas.height = heightmapHeight;
        heightmapCtx = heightmapCanvas.getContext('2d', { willReadFrequently: true });
        heightmapCtx.drawImage(texImg, 0, 0, heightmapWidth, heightmapHeight);
      }
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      try {
        const texture = await createTextureFromFile(file);
        await applyHeightmapTexture(texture);
        console.log('Heightmap loaded:', file.name);
      } catch (err) {
        console.error('Failed to load heightmap texture', err);
      }
    });

    async function handleDropFile(file) {
      if (!file) return;

      // Handle PLY files
      if (file.name.toLowerCase().endsWith('.ply')) {
        try {
          const geometry = await loadPLYFile(file);

          // Clear existing point cloud
          if (extractedPointCloud) {
            scene.remove(extractedPointCloud);
            if (extractedPointCloud.geometry) extractedPointCloud.geometry.dispose();
          }

          // Hide heightmap tiles
          for (const p of tilesPoints) p.visible = false;

          // Create point cloud from PLY
          extractedPointCloud = new THREE.Points(geometry, tilesPointMaterial);
          extractedPointCloud.frustumCulled = false;
          scene.add(extractedPointCloud);

          // Update mode selection
          pointCloudMode = 'ply';
          sourceParams.mode = 'ply';
          pane.refresh();
          updateSourceVisibility();

          console.log('PLY loaded via drop:', geometry.getAttribute('position').count, 'points');
        } catch (err) {
          console.error('Failed to load PLY file:', err);
        }
        return;
      }

      // Handle image files (heightmaps)
      if (!file.type.startsWith('image/')) return;
      try {
        const texture = await createTextureFromFile(file);
        await applyHeightmapTexture(texture);
        // Switch back to heightmap mode
        pointCloudMode = 'heightmap';
        sourceParams.mode = 'heightmap';
        pane.refresh();
        updateSourceVisibility();
      } catch (err) {
        console.error('Failed to load dropped heightmap', err);
      }
    }

    renderer.domElement.addEventListener('dragover', (e) => {
      e.preventDefault();
      renderer.domElement.classList.add('drag-over');
    });

    renderer.domElement.addEventListener('dragleave', () => {
      renderer.domElement.classList.remove('drag-over');
    });

    renderer.domElement.addEventListener('drop', (e) => {
      e.preventDefault();
      renderer.domElement.classList.remove('drag-over');
      const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) {
        handleDropFile(file);
      }
    });

    // Resize handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      pointMaterial.uniforms.uTime.value = performance.now() * 0.001;
      // Update hover center from mouse ray on ground plane
      // reuse a simple ray each frame based on last mouse NDC
      if (!window.__raycaster) window.__raycaster = new THREE.Raycaster();
      if (!window.__mouseNdc) window.__mouseNdc = new THREE.Vector2(-2, -2);
      const ray = window.__raycaster;
      ray.setFromCamera(window.__mouseNdc, camera);
      const hit = new THREE.Vector3();
      const ground = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      if (ray.ray.intersectPlane(ground, hit)) {
        pointMaterial.uniforms.uHoverCenter.value.set(hit.x, hit.z);
      } else {
        pointMaterial.uniforms.uHoverCenter.value.set(9999.0, 9999.0);
      }
      if (params.animateScroll && tilesPoints && tilesPoints.length) {
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        if (forward.lengthSq() < 1e-6) forward.set(0, 0, -1);
        forward.normalize();
        const step = state.scrollSpeed * delta;
        scrollOffset.x += forward.x * step;
        scrollOffset.y += forward.z * step;
        updateTileMatrices();
      }
      // Update airplane
      updateAirplane(delta);
      // Update airplane hover position for shader
      if (airplaneGroup && airplaneState.enabled) {
        pointMaterial.uniforms.uAirplanePos.value.copy(airplaneGroup.position);
      } else {
        pointMaterial.uniforms.uAirplanePos.value.set(9999, 9999, 9999);
      }
      // Update 3D Tiles renderer
      if (tilesRenderer && tiles3DState.enabled) {
        tilesRenderer.update();
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>


